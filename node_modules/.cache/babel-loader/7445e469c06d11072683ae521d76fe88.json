{"ast":null,"code":"import { Util } from '../Util.js';\nimport { Factory } from '../Factory.js';\nimport { Shape } from '../Shape.js';\nimport { Path } from './Path.js';\nimport { Text, stringToArray } from './Text.js';\nimport { getNumberValidator } from '../Validators.js';\nimport { _registerNode } from '../Global.js';\nvar EMPTY_STRING = '',\n    NORMAL = 'normal';\n\nfunction _fillFunc(context) {\n  context.fillText(this.partialText, 0, 0);\n}\n\nfunction _strokeFunc(context) {\n  context.strokeText(this.partialText, 0, 0);\n}\n\nexport class TextPath extends Shape {\n  constructor(config) {\n    super(config);\n    this.dummyCanvas = Util.createCanvasElement();\n    this.dataArray = [];\n    this.dataArray = Path.parsePathData(this.attrs.data);\n    this.on('dataChange.konva', function () {\n      this.dataArray = Path.parsePathData(this.attrs.data);\n\n      this._setTextData();\n    });\n    this.on('textChange.konva alignChange.konva letterSpacingChange.konva kerningFuncChange.konva fontSizeChange.konva', this._setTextData);\n\n    this._setTextData();\n  }\n\n  _sceneFunc(context) {\n    context.setAttr('font', this._getContextFont());\n    context.setAttr('textBaseline', this.textBaseline());\n    context.setAttr('textAlign', 'left');\n    context.save();\n    var textDecoration = this.textDecoration();\n    var fill = this.fill();\n    var fontSize = this.fontSize();\n    var glyphInfo = this.glyphInfo;\n\n    if (textDecoration === 'underline') {\n      context.beginPath();\n    }\n\n    for (var i = 0; i < glyphInfo.length; i++) {\n      context.save();\n      var p0 = glyphInfo[i].p0;\n      context.translate(p0.x, p0.y);\n      context.rotate(glyphInfo[i].rotation);\n      this.partialText = glyphInfo[i].text;\n      context.fillStrokeShape(this);\n\n      if (textDecoration === 'underline') {\n        if (i === 0) {\n          context.moveTo(0, fontSize / 2 + 1);\n        }\n\n        context.lineTo(fontSize, fontSize / 2 + 1);\n      }\n\n      context.restore();\n    }\n\n    if (textDecoration === 'underline') {\n      context.strokeStyle = fill;\n      context.lineWidth = fontSize / 20;\n      context.stroke();\n    }\n\n    context.restore();\n  }\n\n  _hitFunc(context) {\n    context.beginPath();\n    var glyphInfo = this.glyphInfo;\n\n    if (glyphInfo.length >= 1) {\n      var p0 = glyphInfo[0].p0;\n      context.moveTo(p0.x, p0.y);\n    }\n\n    for (var i = 0; i < glyphInfo.length; i++) {\n      var p1 = glyphInfo[i].p1;\n      context.lineTo(p1.x, p1.y);\n    }\n\n    context.setAttr('lineWidth', this.fontSize());\n    context.setAttr('strokeStyle', this.colorKey);\n    context.stroke();\n  }\n\n  getTextWidth() {\n    return this.textWidth;\n  }\n\n  getTextHeight() {\n    Util.warn('text.getTextHeight() method is deprecated. Use text.height() - for full height and text.fontSize() - for one line height.');\n    return this.textHeight;\n  }\n\n  setText(text) {\n    return Text.prototype.setText.call(this, text);\n  }\n\n  _getContextFont() {\n    return Text.prototype._getContextFont.call(this);\n  }\n\n  _getTextSize(text) {\n    var dummyCanvas = this.dummyCanvas;\n\n    var _context = dummyCanvas.getContext('2d');\n\n    _context.save();\n\n    _context.font = this._getContextFont();\n\n    var metrics = _context.measureText(text);\n\n    _context.restore();\n\n    return {\n      width: metrics.width,\n      height: parseInt(this.attrs.fontSize, 10)\n    };\n  }\n\n  _setTextData() {\n    var that = this;\n\n    var size = this._getTextSize(this.attrs.text);\n\n    var letterSpacing = this.letterSpacing();\n    var align = this.align();\n    var kerningFunc = this.kerningFunc();\n    this.textWidth = size.width;\n    this.textHeight = size.height;\n    var textFullWidth = Math.max(this.textWidth + ((this.attrs.text || '').length - 1) * letterSpacing, 0);\n    this.glyphInfo = [];\n    var fullPathWidth = 0;\n\n    for (var l = 0; l < that.dataArray.length; l++) {\n      if (that.dataArray[l].pathLength > 0) {\n        fullPathWidth += that.dataArray[l].pathLength;\n      }\n    }\n\n    var offset = 0;\n\n    if (align === 'center') {\n      offset = Math.max(0, fullPathWidth / 2 - textFullWidth / 2);\n    }\n\n    if (align === 'right') {\n      offset = Math.max(0, fullPathWidth - textFullWidth);\n    }\n\n    var charArr = stringToArray(this.text());\n    var spacesNumber = this.text().split(' ').length - 1;\n    var p0, p1, pathCmd;\n    var pIndex = -1;\n    var currentT = 0;\n\n    var getNextPathSegment = function () {\n      currentT = 0;\n      var pathData = that.dataArray;\n\n      for (var j = pIndex + 1; j < pathData.length; j++) {\n        if (pathData[j].pathLength > 0) {\n          pIndex = j;\n          return pathData[j];\n        } else if (pathData[j].command === 'M') {\n          p0 = {\n            x: pathData[j].points[0],\n            y: pathData[j].points[1]\n          };\n        }\n      }\n\n      return {};\n    };\n\n    var findSegmentToFitCharacter = function (c) {\n      var glyphWidth = that._getTextSize(c).width + letterSpacing;\n\n      if (c === ' ' && align === 'justify') {\n        glyphWidth += (fullPathWidth - textFullWidth) / spacesNumber;\n      }\n\n      var currLen = 0;\n      var attempts = 0;\n      p1 = undefined;\n\n      while (Math.abs(glyphWidth - currLen) / glyphWidth > 0.01 && attempts < 20) {\n        attempts++;\n        var cumulativePathLength = currLen;\n\n        while (pathCmd === undefined) {\n          pathCmd = getNextPathSegment();\n\n          if (pathCmd && cumulativePathLength + pathCmd.pathLength < glyphWidth) {\n            cumulativePathLength += pathCmd.pathLength;\n            pathCmd = undefined;\n          }\n        }\n\n        if (pathCmd === {} || p0 === undefined) {\n          return undefined;\n        }\n\n        var needNewSegment = false;\n\n        switch (pathCmd.command) {\n          case 'L':\n            if (Path.getLineLength(p0.x, p0.y, pathCmd.points[0], pathCmd.points[1]) > glyphWidth) {\n              p1 = Path.getPointOnLine(glyphWidth, p0.x, p0.y, pathCmd.points[0], pathCmd.points[1], p0.x, p0.y);\n            } else {\n              pathCmd = undefined;\n            }\n\n            break;\n\n          case 'A':\n            var start = pathCmd.points[4];\n            var dTheta = pathCmd.points[5];\n            var end = pathCmd.points[4] + dTheta;\n\n            if (currentT === 0) {\n              currentT = start + 0.00000001;\n            } else if (glyphWidth > currLen) {\n              currentT += Math.PI / 180.0 * dTheta / Math.abs(dTheta);\n            } else {\n              currentT -= Math.PI / 360.0 * dTheta / Math.abs(dTheta);\n            }\n\n            if (dTheta < 0 && currentT < end || dTheta >= 0 && currentT > end) {\n              currentT = end;\n              needNewSegment = true;\n            }\n\n            p1 = Path.getPointOnEllipticalArc(pathCmd.points[0], pathCmd.points[1], pathCmd.points[2], pathCmd.points[3], currentT, pathCmd.points[6]);\n            break;\n\n          case 'C':\n            if (currentT === 0) {\n              if (glyphWidth > pathCmd.pathLength) {\n                currentT = 0.00000001;\n              } else {\n                currentT = glyphWidth / pathCmd.pathLength;\n              }\n            } else if (glyphWidth > currLen) {\n              currentT += (glyphWidth - currLen) / pathCmd.pathLength / 2;\n            } else {\n              currentT = Math.max(currentT - (currLen - glyphWidth) / pathCmd.pathLength / 2, 0);\n            }\n\n            if (currentT > 1.0) {\n              currentT = 1.0;\n              needNewSegment = true;\n            }\n\n            p1 = Path.getPointOnCubicBezier(currentT, pathCmd.start.x, pathCmd.start.y, pathCmd.points[0], pathCmd.points[1], pathCmd.points[2], pathCmd.points[3], pathCmd.points[4], pathCmd.points[5]);\n            break;\n\n          case 'Q':\n            if (currentT === 0) {\n              currentT = glyphWidth / pathCmd.pathLength;\n            } else if (glyphWidth > currLen) {\n              currentT += (glyphWidth - currLen) / pathCmd.pathLength;\n            } else {\n              currentT -= (currLen - glyphWidth) / pathCmd.pathLength;\n            }\n\n            if (currentT > 1.0) {\n              currentT = 1.0;\n              needNewSegment = true;\n            }\n\n            p1 = Path.getPointOnQuadraticBezier(currentT, pathCmd.start.x, pathCmd.start.y, pathCmd.points[0], pathCmd.points[1], pathCmd.points[2], pathCmd.points[3]);\n            break;\n        }\n\n        if (p1 !== undefined) {\n          currLen = Path.getLineLength(p0.x, p0.y, p1.x, p1.y);\n        }\n\n        if (needNewSegment) {\n          needNewSegment = false;\n          pathCmd = undefined;\n        }\n      }\n    };\n\n    var testChar = 'C';\n    var glyphWidth = that._getTextSize(testChar).width + letterSpacing;\n    var lettersInOffset = offset / glyphWidth - 1;\n\n    for (var k = 0; k < lettersInOffset; k++) {\n      findSegmentToFitCharacter(testChar);\n\n      if (p0 === undefined || p1 === undefined) {\n        break;\n      }\n\n      p0 = p1;\n    }\n\n    for (var i = 0; i < charArr.length; i++) {\n      findSegmentToFitCharacter(charArr[i]);\n\n      if (p0 === undefined || p1 === undefined) {\n        break;\n      }\n\n      var width = Path.getLineLength(p0.x, p0.y, p1.x, p1.y);\n      var kern = 0;\n\n      if (kerningFunc) {\n        try {\n          kern = kerningFunc(charArr[i - 1], charArr[i]) * this.fontSize();\n        } catch (e) {\n          kern = 0;\n        }\n      }\n\n      p0.x += kern;\n      p1.x += kern;\n      this.textWidth += kern;\n      var midpoint = Path.getPointOnLine(kern + width / 2.0, p0.x, p0.y, p1.x, p1.y);\n      var rotation = Math.atan2(p1.y - p0.y, p1.x - p0.x);\n      this.glyphInfo.push({\n        transposeX: midpoint.x,\n        transposeY: midpoint.y,\n        text: charArr[i],\n        rotation: rotation,\n        p0: p0,\n        p1: p1\n      });\n      p0 = p1;\n    }\n  }\n\n  getSelfRect() {\n    if (!this.glyphInfo.length) {\n      return {\n        x: 0,\n        y: 0,\n        width: 0,\n        height: 0\n      };\n    }\n\n    var points = [];\n    this.glyphInfo.forEach(function (info) {\n      points.push(info.p0.x);\n      points.push(info.p0.y);\n      points.push(info.p1.x);\n      points.push(info.p1.y);\n    });\n    var minX = points[0] || 0;\n    var maxX = points[0] || 0;\n    var minY = points[1] || 0;\n    var maxY = points[1] || 0;\n    var x, y;\n\n    for (var i = 0; i < points.length / 2; i++) {\n      x = points[i * 2];\n      y = points[i * 2 + 1];\n      minX = Math.min(minX, x);\n      maxX = Math.max(maxX, x);\n      minY = Math.min(minY, y);\n      maxY = Math.max(maxY, y);\n    }\n\n    var fontSize = this.fontSize();\n    return {\n      x: minX - fontSize / 2,\n      y: minY - fontSize / 2,\n      width: maxX - minX + fontSize,\n      height: maxY - minY + fontSize\n    };\n  }\n\n}\nTextPath.prototype._fillFunc = _fillFunc;\nTextPath.prototype._strokeFunc = _strokeFunc;\nTextPath.prototype._fillFuncHit = _fillFunc;\nTextPath.prototype._strokeFuncHit = _strokeFunc;\nTextPath.prototype.className = 'TextPath';\nTextPath.prototype._attrsAffectingSize = ['text', 'fontSize', 'data'];\n\n_registerNode(TextPath);\n\nFactory.addGetterSetter(TextPath, 'data');\nFactory.addGetterSetter(TextPath, 'fontFamily', 'Arial');\nFactory.addGetterSetter(TextPath, 'fontSize', 12, getNumberValidator());\nFactory.addGetterSetter(TextPath, 'fontStyle', NORMAL);\nFactory.addGetterSetter(TextPath, 'align', 'left');\nFactory.addGetterSetter(TextPath, 'letterSpacing', 0, getNumberValidator());\nFactory.addGetterSetter(TextPath, 'textBaseline', 'middle');\nFactory.addGetterSetter(TextPath, 'fontVariant', NORMAL);\nFactory.addGetterSetter(TextPath, 'text', EMPTY_STRING);\nFactory.addGetterSetter(TextPath, 'textDecoration', null);\nFactory.addGetterSetter(TextPath, 'kerningFunc', null);","map":{"version":3,"sources":["../../src/shapes/TextPath.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { Util } from '../Util.js';\nimport { Factory } from '../Factory.js';\nimport { Shape } from '../Shape.js';\nimport { Path } from './Path.js';\nimport { Text, stringToArray } from './Text.js';\nimport { getNumberValidator } from '../Validators.js';\nimport { _registerNode } from '../Global.js';\nvar EMPTY_STRING = '', NORMAL = 'normal';\nfunction _fillFunc(context) {\n    context.fillText(this.partialText, 0, 0);\n}\nfunction _strokeFunc(context) {\n    context.strokeText(this.partialText, 0, 0);\n}\nexport class TextPath extends Shape {\n    constructor(config) {\n        super(config);\n        this.dummyCanvas = Util.createCanvasElement();\n        this.dataArray = [];\n        this.dataArray = Path.parsePathData(this.attrs.data);\n        this.on('dataChange.konva', function () {\n            this.dataArray = Path.parsePathData(this.attrs.data);\n            this._setTextData();\n        });\n        this.on('textChange.konva alignChange.konva letterSpacingChange.konva kerningFuncChange.konva fontSizeChange.konva', this._setTextData);\n        this._setTextData();\n    }\n    _sceneFunc(context) {\n        context.setAttr('font', this._getContextFont());\n        context.setAttr('textBaseline', this.textBaseline());\n        context.setAttr('textAlign', 'left');\n        context.save();\n        var textDecoration = this.textDecoration();\n        var fill = this.fill();\n        var fontSize = this.fontSize();\n        var glyphInfo = this.glyphInfo;\n        if (textDecoration === 'underline') {\n            context.beginPath();\n        }\n        for (var i = 0; i < glyphInfo.length; i++) {\n            context.save();\n            var p0 = glyphInfo[i].p0;\n            context.translate(p0.x, p0.y);\n            context.rotate(glyphInfo[i].rotation);\n            this.partialText = glyphInfo[i].text;\n            context.fillStrokeShape(this);\n            if (textDecoration === 'underline') {\n                if (i === 0) {\n                    context.moveTo(0, fontSize / 2 + 1);\n                }\n                context.lineTo(fontSize, fontSize / 2 + 1);\n            }\n            context.restore();\n        }\n        if (textDecoration === 'underline') {\n            context.strokeStyle = fill;\n            context.lineWidth = fontSize / 20;\n            context.stroke();\n        }\n        context.restore();\n    }\n    _hitFunc(context) {\n        context.beginPath();\n        var glyphInfo = this.glyphInfo;\n        if (glyphInfo.length >= 1) {\n            var p0 = glyphInfo[0].p0;\n            context.moveTo(p0.x, p0.y);\n        }\n        for (var i = 0; i < glyphInfo.length; i++) {\n            var p1 = glyphInfo[i].p1;\n            context.lineTo(p1.x, p1.y);\n        }\n        context.setAttr('lineWidth', this.fontSize());\n        context.setAttr('strokeStyle', this.colorKey);\n        context.stroke();\n    }\n    getTextWidth() {\n        return this.textWidth;\n    }\n    getTextHeight() {\n        Util.warn('text.getTextHeight() method is deprecated. Use text.height() - for full height and text.fontSize() - for one line height.');\n        return this.textHeight;\n    }\n    setText(text) {\n        return Text.prototype.setText.call(this, text);\n    }\n    _getContextFont() {\n        return Text.prototype._getContextFont.call(this);\n    }\n    _getTextSize(text) {\n        var dummyCanvas = this.dummyCanvas;\n        var _context = dummyCanvas.getContext('2d');\n        _context.save();\n        _context.font = this._getContextFont();\n        var metrics = _context.measureText(text);\n        _context.restore();\n        return {\n            width: metrics.width,\n            height: parseInt(this.attrs.fontSize, 10),\n        };\n    }\n    _setTextData() {\n        var that = this;\n        var size = this._getTextSize(this.attrs.text);\n        var letterSpacing = this.letterSpacing();\n        var align = this.align();\n        var kerningFunc = this.kerningFunc();\n        this.textWidth = size.width;\n        this.textHeight = size.height;\n        var textFullWidth = Math.max(this.textWidth + ((this.attrs.text || '').length - 1) * letterSpacing, 0);\n        this.glyphInfo = [];\n        var fullPathWidth = 0;\n        for (var l = 0; l < that.dataArray.length; l++) {\n            if (that.dataArray[l].pathLength > 0) {\n                fullPathWidth += that.dataArray[l].pathLength;\n            }\n        }\n        var offset = 0;\n        if (align === 'center') {\n            offset = Math.max(0, fullPathWidth / 2 - textFullWidth / 2);\n        }\n        if (align === 'right') {\n            offset = Math.max(0, fullPathWidth - textFullWidth);\n        }\n        var charArr = stringToArray(this.text());\n        var spacesNumber = this.text().split(' ').length - 1;\n        var p0, p1, pathCmd;\n        var pIndex = -1;\n        var currentT = 0;\n        var getNextPathSegment = function () {\n            currentT = 0;\n            var pathData = that.dataArray;\n            for (var j = pIndex + 1; j < pathData.length; j++) {\n                if (pathData[j].pathLength > 0) {\n                    pIndex = j;\n                    return pathData[j];\n                }\n                else if (pathData[j].command === 'M') {\n                    p0 = {\n                        x: pathData[j].points[0],\n                        y: pathData[j].points[1],\n                    };\n                }\n            }\n            return {};\n        };\n        var findSegmentToFitCharacter = function (c) {\n            var glyphWidth = that._getTextSize(c).width + letterSpacing;\n            if (c === ' ' && align === 'justify') {\n                glyphWidth += (fullPathWidth - textFullWidth) / spacesNumber;\n            }\n            var currLen = 0;\n            var attempts = 0;\n            p1 = undefined;\n            while (Math.abs(glyphWidth - currLen) / glyphWidth > 0.01 &&\n                attempts < 20) {\n                attempts++;\n                var cumulativePathLength = currLen;\n                while (pathCmd === undefined) {\n                    pathCmd = getNextPathSegment();\n                    if (pathCmd &&\n                        cumulativePathLength + pathCmd.pathLength < glyphWidth) {\n                        cumulativePathLength += pathCmd.pathLength;\n                        pathCmd = undefined;\n                    }\n                }\n                if (pathCmd === {} || p0 === undefined) {\n                    return undefined;\n                }\n                var needNewSegment = false;\n                switch (pathCmd.command) {\n                    case 'L':\n                        if (Path.getLineLength(p0.x, p0.y, pathCmd.points[0], pathCmd.points[1]) > glyphWidth) {\n                            p1 = Path.getPointOnLine(glyphWidth, p0.x, p0.y, pathCmd.points[0], pathCmd.points[1], p0.x, p0.y);\n                        }\n                        else {\n                            pathCmd = undefined;\n                        }\n                        break;\n                    case 'A':\n                        var start = pathCmd.points[4];\n                        var dTheta = pathCmd.points[5];\n                        var end = pathCmd.points[4] + dTheta;\n                        if (currentT === 0) {\n                            currentT = start + 0.00000001;\n                        }\n                        else if (glyphWidth > currLen) {\n                            currentT += ((Math.PI / 180.0) * dTheta) / Math.abs(dTheta);\n                        }\n                        else {\n                            currentT -= ((Math.PI / 360.0) * dTheta) / Math.abs(dTheta);\n                        }\n                        if ((dTheta < 0 && currentT < end) ||\n                            (dTheta >= 0 && currentT > end)) {\n                            currentT = end;\n                            needNewSegment = true;\n                        }\n                        p1 = Path.getPointOnEllipticalArc(pathCmd.points[0], pathCmd.points[1], pathCmd.points[2], pathCmd.points[3], currentT, pathCmd.points[6]);\n                        break;\n                    case 'C':\n                        if (currentT === 0) {\n                            if (glyphWidth > pathCmd.pathLength) {\n                                currentT = 0.00000001;\n                            }\n                            else {\n                                currentT = glyphWidth / pathCmd.pathLength;\n                            }\n                        }\n                        else if (glyphWidth > currLen) {\n                            currentT += (glyphWidth - currLen) / pathCmd.pathLength / 2;\n                        }\n                        else {\n                            currentT = Math.max(currentT - (currLen - glyphWidth) / pathCmd.pathLength / 2, 0);\n                        }\n                        if (currentT > 1.0) {\n                            currentT = 1.0;\n                            needNewSegment = true;\n                        }\n                        p1 = Path.getPointOnCubicBezier(currentT, pathCmd.start.x, pathCmd.start.y, pathCmd.points[0], pathCmd.points[1], pathCmd.points[2], pathCmd.points[3], pathCmd.points[4], pathCmd.points[5]);\n                        break;\n                    case 'Q':\n                        if (currentT === 0) {\n                            currentT = glyphWidth / pathCmd.pathLength;\n                        }\n                        else if (glyphWidth > currLen) {\n                            currentT += (glyphWidth - currLen) / pathCmd.pathLength;\n                        }\n                        else {\n                            currentT -= (currLen - glyphWidth) / pathCmd.pathLength;\n                        }\n                        if (currentT > 1.0) {\n                            currentT = 1.0;\n                            needNewSegment = true;\n                        }\n                        p1 = Path.getPointOnQuadraticBezier(currentT, pathCmd.start.x, pathCmd.start.y, pathCmd.points[0], pathCmd.points[1], pathCmd.points[2], pathCmd.points[3]);\n                        break;\n                }\n                if (p1 !== undefined) {\n                    currLen = Path.getLineLength(p0.x, p0.y, p1.x, p1.y);\n                }\n                if (needNewSegment) {\n                    needNewSegment = false;\n                    pathCmd = undefined;\n                }\n            }\n        };\n        var testChar = 'C';\n        var glyphWidth = that._getTextSize(testChar).width + letterSpacing;\n        var lettersInOffset = offset / glyphWidth - 1;\n        for (var k = 0; k < lettersInOffset; k++) {\n            findSegmentToFitCharacter(testChar);\n            if (p0 === undefined || p1 === undefined) {\n                break;\n            }\n            p0 = p1;\n        }\n        for (var i = 0; i < charArr.length; i++) {\n            findSegmentToFitCharacter(charArr[i]);\n            if (p0 === undefined || p1 === undefined) {\n                break;\n            }\n            var width = Path.getLineLength(p0.x, p0.y, p1.x, p1.y);\n            var kern = 0;\n            if (kerningFunc) {\n                try {\n                    kern = kerningFunc(charArr[i - 1], charArr[i]) * this.fontSize();\n                }\n                catch (e) {\n                    kern = 0;\n                }\n            }\n            p0.x += kern;\n            p1.x += kern;\n            this.textWidth += kern;\n            var midpoint = Path.getPointOnLine(kern + width / 2.0, p0.x, p0.y, p1.x, p1.y);\n            var rotation = Math.atan2(p1.y - p0.y, p1.x - p0.x);\n            this.glyphInfo.push({\n                transposeX: midpoint.x,\n                transposeY: midpoint.y,\n                text: charArr[i],\n                rotation: rotation,\n                p0: p0,\n                p1: p1,\n            });\n            p0 = p1;\n        }\n    }\n    getSelfRect() {\n        if (!this.glyphInfo.length) {\n            return {\n                x: 0,\n                y: 0,\n                width: 0,\n                height: 0,\n            };\n        }\n        var points = [];\n        this.glyphInfo.forEach(function (info) {\n            points.push(info.p0.x);\n            points.push(info.p0.y);\n            points.push(info.p1.x);\n            points.push(info.p1.y);\n        });\n        var minX = points[0] || 0;\n        var maxX = points[0] || 0;\n        var minY = points[1] || 0;\n        var maxY = points[1] || 0;\n        var x, y;\n        for (var i = 0; i < points.length / 2; i++) {\n            x = points[i * 2];\n            y = points[i * 2 + 1];\n            minX = Math.min(minX, x);\n            maxX = Math.max(maxX, x);\n            minY = Math.min(minY, y);\n            maxY = Math.max(maxY, y);\n        }\n        var fontSize = this.fontSize();\n        return {\n            x: minX - fontSize / 2,\n            y: minY - fontSize / 2,\n            width: maxX - minX + fontSize,\n            height: maxY - minY + fontSize,\n        };\n    }\n}\nTextPath.prototype._fillFunc = _fillFunc;\nTextPath.prototype._strokeFunc = _strokeFunc;\nTextPath.prototype._fillFuncHit = _fillFunc;\nTextPath.prototype._strokeFuncHit = _strokeFunc;\nTextPath.prototype.className = 'TextPath';\nTextPath.prototype._attrsAffectingSize = ['text', 'fontSize', 'data'];\n_registerNode(TextPath);\nFactory.addGetterSetter(TextPath, 'data');\nFactory.addGetterSetter(TextPath, 'fontFamily', 'Arial');\nFactory.addGetterSetter(TextPath, 'fontSize', 12, getNumberValidator());\nFactory.addGetterSetter(TextPath, 'fontStyle', NORMAL);\nFactory.addGetterSetter(TextPath, 'align', 'left');\nFactory.addGetterSetter(TextPath, 'letterSpacing', 0, getNumberValidator());\nFactory.addGetterSetter(TextPath, 'textBaseline', 'middle');\nFactory.addGetterSetter(TextPath, 'fontVariant', NORMAL);\nFactory.addGetterSetter(TextPath, 'text', EMPTY_STRING);\nFactory.addGetterSetter(TextPath, 'textDecoration', null);\nFactory.addGetterSetter(TextPath, 'kerningFunc', null);\n//# sourceMappingURL=TextPath.js.map"]},"metadata":{},"sourceType":"module"}