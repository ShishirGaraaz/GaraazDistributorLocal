{"ast":null,"code":"import { Util } from './Util.js';\nimport { Factory } from './Factory.js';\nimport { Container } from './Container.js';\nimport { Konva } from './Global.js';\nimport { SceneCanvas, HitCanvas } from './Canvas.js';\nimport { DD } from './DragAndDrop.js';\nimport { _registerNode } from './Global.js';\nimport * as PointerEvents from './PointerEvents.js';\nvar STAGE = 'Stage',\n    STRING = 'string',\n    PX = 'px',\n    MOUSEOUT = 'mouseout',\n    MOUSELEAVE = 'mouseleave',\n    MOUSEOVER = 'mouseover',\n    MOUSEENTER = 'mouseenter',\n    MOUSEMOVE = 'mousemove',\n    MOUSEDOWN = 'mousedown',\n    MOUSEUP = 'mouseup',\n    POINTERMOVE = 'pointermove',\n    POINTERDOWN = 'pointerdown',\n    POINTERUP = 'pointerup',\n    POINTERCANCEL = 'pointercancel',\n    LOSTPOINTERCAPTURE = 'lostpointercapture',\n    POINTEROUT = 'pointerout',\n    POINTERLEAVE = 'pointerleave',\n    POINTEROVER = 'pointerover',\n    POINTERENTER = 'pointerenter',\n    CONTEXTMENU = 'contextmenu',\n    TOUCHSTART = 'touchstart',\n    TOUCHEND = 'touchend',\n    TOUCHMOVE = 'touchmove',\n    TOUCHCANCEL = 'touchcancel',\n    WHEEL = 'wheel',\n    MAX_LAYERS_NUMBER = 5,\n    EVENTS = [[MOUSEENTER, '_pointerenter'], [MOUSEDOWN, '_pointerdown'], [MOUSEMOVE, '_pointermove'], [MOUSEUP, '_pointerup'], [MOUSELEAVE, '_pointerleave'], [TOUCHSTART, '_pointerdown'], [TOUCHMOVE, '_pointermove'], [TOUCHEND, '_pointerup'], [TOUCHCANCEL, '_pointercancel'], [MOUSEOVER, '_pointerover'], [WHEEL, '_wheel'], [CONTEXTMENU, '_contextmenu'], [POINTERDOWN, '_pointerdown'], [POINTERMOVE, '_pointermove'], [POINTERUP, '_pointerup'], [POINTERCANCEL, '_pointercancel'], [LOSTPOINTERCAPTURE, '_lostpointercapture']];\nconst EVENTS_MAP = {\n  mouse: {\n    [POINTEROUT]: MOUSEOUT,\n    [POINTERLEAVE]: MOUSELEAVE,\n    [POINTEROVER]: MOUSEOVER,\n    [POINTERENTER]: MOUSEENTER,\n    [POINTERMOVE]: MOUSEMOVE,\n    [POINTERDOWN]: MOUSEDOWN,\n    [POINTERUP]: MOUSEUP,\n    [POINTERCANCEL]: 'mousecancel',\n    pointerclick: 'click',\n    pointerdblclick: 'dblclick'\n  },\n  touch: {\n    [POINTEROUT]: 'touchout',\n    [POINTERLEAVE]: 'touchleave',\n    [POINTEROVER]: 'touchover',\n    [POINTERENTER]: 'touchenter',\n    [POINTERMOVE]: TOUCHMOVE,\n    [POINTERDOWN]: TOUCHSTART,\n    [POINTERUP]: TOUCHEND,\n    [POINTERCANCEL]: TOUCHCANCEL,\n    pointerclick: 'tap',\n    pointerdblclick: 'dbltap'\n  },\n  pointer: {\n    [POINTEROUT]: POINTEROUT,\n    [POINTERLEAVE]: POINTERLEAVE,\n    [POINTEROVER]: POINTEROVER,\n    [POINTERENTER]: POINTERENTER,\n    [POINTERMOVE]: POINTERMOVE,\n    [POINTERDOWN]: POINTERDOWN,\n    [POINTERUP]: POINTERUP,\n    [POINTERCANCEL]: POINTERCANCEL,\n    pointerclick: 'pointerclick',\n    pointerdblclick: 'pointerdblclick'\n  }\n};\n\nconst getEventType = type => {\n  if (type.indexOf('pointer') >= 0) {\n    return 'pointer';\n  }\n\n  if (type.indexOf('touch') >= 0) {\n    return 'touch';\n  }\n\n  return 'mouse';\n};\n\nconst getEventsMap = eventType => {\n  const type = getEventType(eventType);\n\n  if (type === 'pointer') {\n    return Konva.pointerEventsEnabled && EVENTS_MAP.pointer;\n  }\n\n  if (type === 'touch') {\n    return EVENTS_MAP.touch;\n  }\n\n  if (type === 'mouse') {\n    return EVENTS_MAP.mouse;\n  }\n};\n\nfunction checkNoClip() {\n  let attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  if (attrs.clipFunc || attrs.clipWidth || attrs.clipHeight) {\n    Util.warn('Stage does not support clipping. Please use clip for Layers or Groups.');\n  }\n\n  return attrs;\n}\n\nconst NO_POINTERS_MESSAGE = `Pointer position is missing and not registered by the stage. Looks like it is outside of the stage container. You can set it manually from event: stage.setPointersPositions(event);`;\nexport const stages = [];\nexport class Stage extends Container {\n  constructor(config) {\n    super(checkNoClip(config));\n    this._pointerPositions = [];\n    this._changedPointerPositions = [];\n\n    this._buildDOM();\n\n    this._bindContentEvents();\n\n    stages.push(this);\n    this.on('widthChange.konva heightChange.konva', this._resizeDOM);\n    this.on('visibleChange.konva', this._checkVisibility);\n    this.on('clipWidthChange.konva clipHeightChange.konva clipFuncChange.konva', () => {\n      checkNoClip(this.attrs);\n    });\n\n    this._checkVisibility();\n  }\n\n  _validateAdd(child) {\n    const isLayer = child.getType() === 'Layer';\n    const isFastLayer = child.getType() === 'FastLayer';\n    const valid = isLayer || isFastLayer;\n\n    if (!valid) {\n      Util.throw('You may only add layers to the stage.');\n    }\n  }\n\n  _checkVisibility() {\n    if (!this.content) {\n      return;\n    }\n\n    const style = this.visible() ? '' : 'none';\n    this.content.style.display = style;\n  }\n\n  setContainer(container) {\n    if (typeof container === STRING) {\n      if (container.charAt(0) === '.') {\n        var className = container.slice(1);\n        container = document.getElementsByClassName(className)[0];\n      } else {\n        var id;\n\n        if (container.charAt(0) !== '#') {\n          id = container;\n        } else {\n          id = container.slice(1);\n        }\n\n        container = document.getElementById(id);\n      }\n\n      if (!container) {\n        throw 'Can not find container in document with id ' + id;\n      }\n    }\n\n    this._setAttr('container', container);\n\n    if (this.content) {\n      if (this.content.parentElement) {\n        this.content.parentElement.removeChild(this.content);\n      }\n\n      container.appendChild(this.content);\n    }\n\n    return this;\n  }\n\n  shouldDrawHit() {\n    return true;\n  }\n\n  clear() {\n    var layers = this.children,\n        len = layers.length,\n        n;\n\n    for (n = 0; n < len; n++) {\n      layers[n].clear();\n    }\n\n    return this;\n  }\n\n  clone(obj) {\n    if (!obj) {\n      obj = {};\n    }\n\n    obj.container = typeof document !== 'undefined' && document.createElement('div');\n    return Container.prototype.clone.call(this, obj);\n  }\n\n  destroy() {\n    super.destroy();\n    var content = this.content;\n\n    if (content && Util._isInDocument(content)) {\n      this.container().removeChild(content);\n    }\n\n    var index = stages.indexOf(this);\n\n    if (index > -1) {\n      stages.splice(index, 1);\n    }\n\n    return this;\n  }\n\n  getPointerPosition() {\n    const pos = this._pointerPositions[0] || this._changedPointerPositions[0];\n\n    if (!pos) {\n      Util.warn(NO_POINTERS_MESSAGE);\n      return null;\n    }\n\n    return {\n      x: pos.x,\n      y: pos.y\n    };\n  }\n\n  _getPointerById(id) {\n    return this._pointerPositions.find(p => p.id === id);\n  }\n\n  getPointersPositions() {\n    return this._pointerPositions;\n  }\n\n  getStage() {\n    return this;\n  }\n\n  getContent() {\n    return this.content;\n  }\n\n  _toKonvaCanvas(config) {\n    config = config || {};\n    config.x = config.x || 0;\n    config.y = config.y || 0;\n    config.width = config.width || this.width();\n    config.height = config.height || this.height();\n    var canvas = new SceneCanvas({\n      width: config.width,\n      height: config.height,\n      pixelRatio: config.pixelRatio || 1\n    });\n\n    var _context = canvas.getContext()._context;\n\n    var layers = this.children;\n\n    if (config.x || config.y) {\n      _context.translate(-1 * config.x, -1 * config.y);\n    }\n\n    layers.forEach(function (layer) {\n      if (!layer.isVisible()) {\n        return;\n      }\n\n      var layerCanvas = layer._toKonvaCanvas(config);\n\n      _context.drawImage(layerCanvas._canvas, config.x, config.y, layerCanvas.getWidth() / layerCanvas.getPixelRatio(), layerCanvas.getHeight() / layerCanvas.getPixelRatio());\n    });\n    return canvas;\n  }\n\n  getIntersection(pos) {\n    if (!pos) {\n      return null;\n    }\n\n    var layers = this.children,\n        len = layers.length,\n        end = len - 1,\n        n;\n\n    for (n = end; n >= 0; n--) {\n      const shape = layers[n].getIntersection(pos);\n\n      if (shape) {\n        return shape;\n      }\n    }\n\n    return null;\n  }\n\n  _resizeDOM() {\n    var width = this.width();\n    var height = this.height();\n\n    if (this.content) {\n      this.content.style.width = width + PX;\n      this.content.style.height = height + PX;\n    }\n\n    this.bufferCanvas.setSize(width, height);\n    this.bufferHitCanvas.setSize(width, height);\n    this.children.forEach(layer => {\n      layer.setSize({\n        width,\n        height\n      });\n      layer.draw();\n    });\n  }\n\n  add(layer) {\n    for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      rest[_key - 1] = arguments[_key];\n    }\n\n    if (arguments.length > 1) {\n      for (var i = 0; i < arguments.length; i++) {\n        this.add(arguments[i]);\n      }\n\n      return this;\n    }\n\n    super.add(layer);\n    var length = this.children.length;\n\n    if (length > MAX_LAYERS_NUMBER) {\n      Util.warn('The stage has ' + length + ' layers. Recommended maximum number of layers is 3-5. Adding more layers into the stage may drop the performance. Rethink your tree structure, you can use Konva.Group.');\n    }\n\n    layer.setSize({\n      width: this.width(),\n      height: this.height()\n    });\n    layer.draw();\n\n    if (Konva.isBrowser) {\n      this.content.appendChild(layer.canvas._canvas);\n    }\n\n    return this;\n  }\n\n  getParent() {\n    return null;\n  }\n\n  getLayer() {\n    return null;\n  }\n\n  hasPointerCapture(pointerId) {\n    return PointerEvents.hasPointerCapture(pointerId, this);\n  }\n\n  setPointerCapture(pointerId) {\n    PointerEvents.setPointerCapture(pointerId, this);\n  }\n\n  releaseCapture(pointerId) {\n    PointerEvents.releaseCapture(pointerId, this);\n  }\n\n  getLayers() {\n    return this.children;\n  }\n\n  _bindContentEvents() {\n    if (!Konva.isBrowser) {\n      return;\n    }\n\n    EVENTS.forEach(_ref => {\n      let [event, methodName] = _ref;\n      this.content.addEventListener(event, evt => {\n        this[methodName](evt);\n      });\n    });\n  }\n\n  _pointerenter(evt) {\n    this.setPointersPositions(evt);\n    const events = getEventsMap(evt.type);\n\n    this._fire(events.pointerenter, {\n      evt: evt,\n      target: this,\n      currentTarget: this\n    });\n  }\n\n  _pointerover(evt) {\n    this.setPointersPositions(evt);\n    const events = getEventsMap(evt.type);\n\n    this._fire(events.pointerover, {\n      evt: evt,\n      target: this,\n      currentTarget: this\n    });\n  }\n\n  _getTargetShape(evenType) {\n    let shape = this[evenType + 'targetShape'];\n\n    if (shape && !shape.getStage()) {\n      shape = null;\n    }\n\n    return shape;\n  }\n\n  _pointerleave(evt) {\n    const events = getEventsMap(evt.type);\n    const eventType = getEventType(evt.type);\n\n    if (!events) {\n      return;\n    }\n\n    this.setPointersPositions(evt);\n\n    var targetShape = this._getTargetShape(eventType);\n\n    var eventsEnabled = !DD.isDragging || Konva.hitOnDragEnabled;\n\n    if (targetShape && eventsEnabled) {\n      targetShape._fireAndBubble(events.pointerout, {\n        evt: evt\n      });\n\n      targetShape._fireAndBubble(events.pointerleave, {\n        evt: evt\n      });\n\n      this._fire(events.pointerleave, {\n        evt: evt,\n        target: this,\n        currentTarget: this\n      });\n\n      this[eventType + 'targetShape'] = null;\n    } else if (eventsEnabled) {\n      this._fire(events.pointerleave, {\n        evt: evt,\n        target: this,\n        currentTarget: this\n      });\n\n      this._fire(events.pointerout, {\n        evt: evt,\n        target: this,\n        currentTarget: this\n      });\n    }\n\n    this.pointerPos = undefined;\n    this._pointerPositions = [];\n  }\n\n  _pointerdown(evt) {\n    const events = getEventsMap(evt.type);\n    const eventType = getEventType(evt.type);\n\n    if (!events) {\n      return;\n    }\n\n    this.setPointersPositions(evt);\n    var triggeredOnShape = false;\n\n    this._changedPointerPositions.forEach(pos => {\n      var shape = this.getIntersection(pos);\n      DD.justDragged = false;\n      Konva['_' + eventType + 'ListenClick'] = true;\n      const hasShape = shape && shape.isListening();\n\n      if (!hasShape) {\n        return;\n      }\n\n      if (Konva.capturePointerEventsEnabled) {\n        shape.setPointerCapture(pos.id);\n      }\n\n      this[eventType + 'ClickStartShape'] = shape;\n\n      shape._fireAndBubble(events.pointerdown, {\n        evt: evt,\n        pointerId: pos.id\n      });\n\n      triggeredOnShape = true;\n      const isTouch = evt.type.indexOf('touch') >= 0;\n\n      if (shape.preventDefault() && evt.cancelable && isTouch) {\n        evt.preventDefault();\n      }\n    });\n\n    if (!triggeredOnShape) {\n      this._fire(events.pointerdown, {\n        evt: evt,\n        target: this,\n        currentTarget: this,\n        pointerId: this._pointerPositions[0].id\n      });\n    }\n  }\n\n  _pointermove(evt) {\n    const events = getEventsMap(evt.type);\n    const eventType = getEventType(evt.type);\n\n    if (!events) {\n      return;\n    }\n\n    if (DD.isDragging && DD.node.preventDefault() && evt.cancelable) {\n      evt.preventDefault();\n    }\n\n    this.setPointersPositions(evt);\n    var eventsEnabled = !DD.isDragging || Konva.hitOnDragEnabled;\n\n    if (!eventsEnabled) {\n      return;\n    }\n\n    var processedShapesIds = {};\n    let triggeredOnShape = false;\n\n    var targetShape = this._getTargetShape(eventType);\n\n    this._changedPointerPositions.forEach(pos => {\n      const shape = PointerEvents.getCapturedShape(pos.id) || this.getIntersection(pos);\n      const pointerId = pos.id;\n      const event = {\n        evt: evt,\n        pointerId\n      };\n      var differentTarget = targetShape !== shape;\n\n      if (differentTarget && targetShape) {\n        targetShape._fireAndBubble(events.pointerout, Object.assign({}, event), shape);\n\n        targetShape._fireAndBubble(events.pointerleave, Object.assign({}, event), shape);\n      }\n\n      if (shape) {\n        if (processedShapesIds[shape._id]) {\n          return;\n        }\n\n        processedShapesIds[shape._id] = true;\n      }\n\n      if (shape && shape.isListening()) {\n        triggeredOnShape = true;\n\n        if (differentTarget) {\n          shape._fireAndBubble(events.pointerover, Object.assign({}, event), targetShape);\n\n          shape._fireAndBubble(events.pointerenter, Object.assign({}, event), targetShape);\n\n          this[eventType + 'targetShape'] = shape;\n        }\n\n        shape._fireAndBubble(events.pointermove, Object.assign({}, event));\n      } else {\n        if (targetShape) {\n          this._fire(events.pointerover, {\n            evt: evt,\n            target: this,\n            currentTarget: this,\n            pointerId\n          });\n\n          this[eventType + 'targetShape'] = null;\n        }\n      }\n    });\n\n    if (!triggeredOnShape) {\n      this._fire(events.pointermove, {\n        evt: evt,\n        target: this,\n        currentTarget: this,\n        pointerId: this._changedPointerPositions[0].id\n      });\n    }\n  }\n\n  _pointerup(evt) {\n    const events = getEventsMap(evt.type);\n    const eventType = getEventType(evt.type);\n\n    if (!events) {\n      return;\n    }\n\n    this.setPointersPositions(evt);\n    const clickStartShape = this[eventType + 'ClickStartShape'];\n    const clickEndShape = this[eventType + 'ClickEndShape'];\n    var processedShapesIds = {};\n    let triggeredOnShape = false;\n\n    this._changedPointerPositions.forEach(pos => {\n      const shape = PointerEvents.getCapturedShape(pos.id) || this.getIntersection(pos);\n\n      if (shape) {\n        shape.releaseCapture(pos.id);\n\n        if (processedShapesIds[shape._id]) {\n          return;\n        }\n\n        processedShapesIds[shape._id] = true;\n      }\n\n      const pointerId = pos.id;\n      const event = {\n        evt: evt,\n        pointerId\n      };\n      let fireDblClick = false;\n\n      if (Konva['_' + eventType + 'InDblClickWindow']) {\n        fireDblClick = true;\n        clearTimeout(this[eventType + 'DblTimeout']);\n      } else if (!DD.justDragged) {\n        Konva['_' + eventType + 'InDblClickWindow'] = true;\n        clearTimeout(this[eventType + 'DblTimeout']);\n      }\n\n      this[eventType + 'DblTimeout'] = setTimeout(function () {\n        Konva['_' + eventType + 'InDblClickWindow'] = false;\n      }, Konva.dblClickWindow);\n\n      if (shape && shape.isListening()) {\n        triggeredOnShape = true;\n        this[eventType + 'ClickEndShape'] = shape;\n\n        shape._fireAndBubble(events.pointerup, Object.assign({}, event));\n\n        if (Konva['_' + eventType + 'ListenClick'] && clickStartShape && clickStartShape === shape) {\n          shape._fireAndBubble(events.pointerclick, Object.assign({}, event));\n\n          if (fireDblClick && clickEndShape && clickEndShape === shape) {\n            shape._fireAndBubble(events.pointerdblclick, Object.assign({}, event));\n          }\n        }\n      } else {\n        this[eventType + 'ClickEndShape'] = null;\n\n        if (Konva['_' + eventType + 'ListenClick']) {\n          this._fire(events.pointerclick, {\n            evt: evt,\n            target: this,\n            currentTarget: this,\n            pointerId\n          });\n        }\n\n        if (fireDblClick) {\n          this._fire(events.pointerdblclick, {\n            evt: evt,\n            target: this,\n            currentTarget: this,\n            pointerId\n          });\n        }\n      }\n    });\n\n    if (!triggeredOnShape) {\n      this._fire(events.pointerup, {\n        evt: evt,\n        target: this,\n        currentTarget: this,\n        pointerId: this._changedPointerPositions[0].id\n      });\n    }\n\n    Konva['_' + eventType + 'ListenClick'] = false;\n\n    if (evt.cancelable) {\n      evt.preventDefault();\n    }\n  }\n\n  _contextmenu(evt) {\n    this.setPointersPositions(evt);\n    var shape = this.getIntersection(this.getPointerPosition());\n\n    if (shape && shape.isListening()) {\n      shape._fireAndBubble(CONTEXTMENU, {\n        evt: evt\n      });\n    } else {\n      this._fire(CONTEXTMENU, {\n        evt: evt,\n        target: this,\n        currentTarget: this\n      });\n    }\n  }\n\n  _wheel(evt) {\n    this.setPointersPositions(evt);\n    var shape = this.getIntersection(this.getPointerPosition());\n\n    if (shape && shape.isListening()) {\n      shape._fireAndBubble(WHEEL, {\n        evt: evt\n      });\n    } else {\n      this._fire(WHEEL, {\n        evt: evt,\n        target: this,\n        currentTarget: this\n      });\n    }\n  }\n\n  _pointercancel(evt) {\n    this.setPointersPositions(evt);\n    const shape = PointerEvents.getCapturedShape(evt.pointerId) || this.getIntersection(this.getPointerPosition());\n\n    if (shape) {\n      shape._fireAndBubble(POINTERUP, PointerEvents.createEvent(evt));\n    }\n\n    PointerEvents.releaseCapture(evt.pointerId);\n  }\n\n  _lostpointercapture(evt) {\n    PointerEvents.releaseCapture(evt.pointerId);\n  }\n\n  setPointersPositions(evt) {\n    var contentPosition = this._getContentPosition(),\n        x = null,\n        y = null;\n\n    evt = evt ? evt : window.event;\n\n    if (evt.touches !== undefined) {\n      this._pointerPositions = [];\n      this._changedPointerPositions = [];\n      Array.prototype.forEach.call(evt.touches, touch => {\n        this._pointerPositions.push({\n          id: touch.identifier,\n          x: (touch.clientX - contentPosition.left) / contentPosition.scaleX,\n          y: (touch.clientY - contentPosition.top) / contentPosition.scaleY\n        });\n      });\n      Array.prototype.forEach.call(evt.changedTouches || evt.touches, touch => {\n        this._changedPointerPositions.push({\n          id: touch.identifier,\n          x: (touch.clientX - contentPosition.left) / contentPosition.scaleX,\n          y: (touch.clientY - contentPosition.top) / contentPosition.scaleY\n        });\n      });\n    } else {\n      x = (evt.clientX - contentPosition.left) / contentPosition.scaleX;\n      y = (evt.clientY - contentPosition.top) / contentPosition.scaleY;\n      this.pointerPos = {\n        x: x,\n        y: y\n      };\n      this._pointerPositions = [{\n        x,\n        y,\n        id: Util._getFirstPointerId(evt)\n      }];\n      this._changedPointerPositions = [{\n        x,\n        y,\n        id: Util._getFirstPointerId(evt)\n      }];\n    }\n  }\n\n  _setPointerPosition(evt) {\n    Util.warn('Method _setPointerPosition is deprecated. Use \"stage.setPointersPositions(event)\" instead.');\n    this.setPointersPositions(evt);\n  }\n\n  _getContentPosition() {\n    if (!this.content || !this.content.getBoundingClientRect) {\n      return {\n        top: 0,\n        left: 0,\n        scaleX: 1,\n        scaleY: 1\n      };\n    }\n\n    var rect = this.content.getBoundingClientRect();\n    return {\n      top: rect.top,\n      left: rect.left,\n      scaleX: rect.width / this.content.clientWidth || 1,\n      scaleY: rect.height / this.content.clientHeight || 1\n    };\n  }\n\n  _buildDOM() {\n    this.bufferCanvas = new SceneCanvas({\n      width: this.width(),\n      height: this.height()\n    });\n    this.bufferHitCanvas = new HitCanvas({\n      pixelRatio: 1,\n      width: this.width(),\n      height: this.height()\n    });\n\n    if (!Konva.isBrowser) {\n      return;\n    }\n\n    var container = this.container();\n\n    if (!container) {\n      throw 'Stage has no container. A container is required.';\n    }\n\n    container.innerHTML = '';\n    this.content = document.createElement('div');\n    this.content.style.position = 'relative';\n    this.content.style.userSelect = 'none';\n    this.content.className = 'konvajs-content';\n    this.content.setAttribute('role', 'presentation');\n    container.appendChild(this.content);\n\n    this._resizeDOM();\n  }\n\n  cache() {\n    Util.warn('Cache function is not allowed for stage. You may use cache only for layers, groups and shapes.');\n    return this;\n  }\n\n  clearCache() {\n    return this;\n  }\n\n  batchDraw() {\n    this.getChildren().forEach(function (layer) {\n      layer.batchDraw();\n    });\n    return this;\n  }\n\n}\nStage.prototype.nodeType = STAGE;\n\n_registerNode(Stage);\n\nFactory.addGetterSetter(Stage, 'container');","map":{"version":3,"sources":["../src/Stage.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { Util } from './Util.js';\nimport { Factory } from './Factory.js';\nimport { Container } from './Container.js';\nimport { Konva } from './Global.js';\nimport { SceneCanvas, HitCanvas } from './Canvas.js';\nimport { DD } from './DragAndDrop.js';\nimport { _registerNode } from './Global.js';\nimport * as PointerEvents from './PointerEvents.js';\nvar STAGE = 'Stage', STRING = 'string', PX = 'px', MOUSEOUT = 'mouseout', MOUSELEAVE = 'mouseleave', MOUSEOVER = 'mouseover', MOUSEENTER = 'mouseenter', MOUSEMOVE = 'mousemove', MOUSEDOWN = 'mousedown', MOUSEUP = 'mouseup', POINTERMOVE = 'pointermove', POINTERDOWN = 'pointerdown', POINTERUP = 'pointerup', POINTERCANCEL = 'pointercancel', LOSTPOINTERCAPTURE = 'lostpointercapture', POINTEROUT = 'pointerout', POINTERLEAVE = 'pointerleave', POINTEROVER = 'pointerover', POINTERENTER = 'pointerenter', CONTEXTMENU = 'contextmenu', TOUCHSTART = 'touchstart', TOUCHEND = 'touchend', TOUCHMOVE = 'touchmove', TOUCHCANCEL = 'touchcancel', WHEEL = 'wheel', MAX_LAYERS_NUMBER = 5, EVENTS = [\n    [MOUSEENTER, '_pointerenter'],\n    [MOUSEDOWN, '_pointerdown'],\n    [MOUSEMOVE, '_pointermove'],\n    [MOUSEUP, '_pointerup'],\n    [MOUSELEAVE, '_pointerleave'],\n    [TOUCHSTART, '_pointerdown'],\n    [TOUCHMOVE, '_pointermove'],\n    [TOUCHEND, '_pointerup'],\n    [TOUCHCANCEL, '_pointercancel'],\n    [MOUSEOVER, '_pointerover'],\n    [WHEEL, '_wheel'],\n    [CONTEXTMENU, '_contextmenu'],\n    [POINTERDOWN, '_pointerdown'],\n    [POINTERMOVE, '_pointermove'],\n    [POINTERUP, '_pointerup'],\n    [POINTERCANCEL, '_pointercancel'],\n    [LOSTPOINTERCAPTURE, '_lostpointercapture'],\n];\nconst EVENTS_MAP = {\n    mouse: {\n        [POINTEROUT]: MOUSEOUT,\n        [POINTERLEAVE]: MOUSELEAVE,\n        [POINTEROVER]: MOUSEOVER,\n        [POINTERENTER]: MOUSEENTER,\n        [POINTERMOVE]: MOUSEMOVE,\n        [POINTERDOWN]: MOUSEDOWN,\n        [POINTERUP]: MOUSEUP,\n        [POINTERCANCEL]: 'mousecancel',\n        pointerclick: 'click',\n        pointerdblclick: 'dblclick',\n    },\n    touch: {\n        [POINTEROUT]: 'touchout',\n        [POINTERLEAVE]: 'touchleave',\n        [POINTEROVER]: 'touchover',\n        [POINTERENTER]: 'touchenter',\n        [POINTERMOVE]: TOUCHMOVE,\n        [POINTERDOWN]: TOUCHSTART,\n        [POINTERUP]: TOUCHEND,\n        [POINTERCANCEL]: TOUCHCANCEL,\n        pointerclick: 'tap',\n        pointerdblclick: 'dbltap',\n    },\n    pointer: {\n        [POINTEROUT]: POINTEROUT,\n        [POINTERLEAVE]: POINTERLEAVE,\n        [POINTEROVER]: POINTEROVER,\n        [POINTERENTER]: POINTERENTER,\n        [POINTERMOVE]: POINTERMOVE,\n        [POINTERDOWN]: POINTERDOWN,\n        [POINTERUP]: POINTERUP,\n        [POINTERCANCEL]: POINTERCANCEL,\n        pointerclick: 'pointerclick',\n        pointerdblclick: 'pointerdblclick',\n    },\n};\nconst getEventType = (type) => {\n    if (type.indexOf('pointer') >= 0) {\n        return 'pointer';\n    }\n    if (type.indexOf('touch') >= 0) {\n        return 'touch';\n    }\n    return 'mouse';\n};\nconst getEventsMap = (eventType) => {\n    const type = getEventType(eventType);\n    if (type === 'pointer') {\n        return Konva.pointerEventsEnabled && EVENTS_MAP.pointer;\n    }\n    if (type === 'touch') {\n        return EVENTS_MAP.touch;\n    }\n    if (type === 'mouse') {\n        return EVENTS_MAP.mouse;\n    }\n};\nfunction checkNoClip(attrs = {}) {\n    if (attrs.clipFunc || attrs.clipWidth || attrs.clipHeight) {\n        Util.warn('Stage does not support clipping. Please use clip for Layers or Groups.');\n    }\n    return attrs;\n}\nconst NO_POINTERS_MESSAGE = `Pointer position is missing and not registered by the stage. Looks like it is outside of the stage container. You can set it manually from event: stage.setPointersPositions(event);`;\nexport const stages = [];\nexport class Stage extends Container {\n    constructor(config) {\n        super(checkNoClip(config));\n        this._pointerPositions = [];\n        this._changedPointerPositions = [];\n        this._buildDOM();\n        this._bindContentEvents();\n        stages.push(this);\n        this.on('widthChange.konva heightChange.konva', this._resizeDOM);\n        this.on('visibleChange.konva', this._checkVisibility);\n        this.on('clipWidthChange.konva clipHeightChange.konva clipFuncChange.konva', () => {\n            checkNoClip(this.attrs);\n        });\n        this._checkVisibility();\n    }\n    _validateAdd(child) {\n        const isLayer = child.getType() === 'Layer';\n        const isFastLayer = child.getType() === 'FastLayer';\n        const valid = isLayer || isFastLayer;\n        if (!valid) {\n            Util.throw('You may only add layers to the stage.');\n        }\n    }\n    _checkVisibility() {\n        if (!this.content) {\n            return;\n        }\n        const style = this.visible() ? '' : 'none';\n        this.content.style.display = style;\n    }\n    setContainer(container) {\n        if (typeof container === STRING) {\n            if (container.charAt(0) === '.') {\n                var className = container.slice(1);\n                container = document.getElementsByClassName(className)[0];\n            }\n            else {\n                var id;\n                if (container.charAt(0) !== '#') {\n                    id = container;\n                }\n                else {\n                    id = container.slice(1);\n                }\n                container = document.getElementById(id);\n            }\n            if (!container) {\n                throw 'Can not find container in document with id ' + id;\n            }\n        }\n        this._setAttr('container', container);\n        if (this.content) {\n            if (this.content.parentElement) {\n                this.content.parentElement.removeChild(this.content);\n            }\n            container.appendChild(this.content);\n        }\n        return this;\n    }\n    shouldDrawHit() {\n        return true;\n    }\n    clear() {\n        var layers = this.children, len = layers.length, n;\n        for (n = 0; n < len; n++) {\n            layers[n].clear();\n        }\n        return this;\n    }\n    clone(obj) {\n        if (!obj) {\n            obj = {};\n        }\n        obj.container =\n            typeof document !== 'undefined' && document.createElement('div');\n        return Container.prototype.clone.call(this, obj);\n    }\n    destroy() {\n        super.destroy();\n        var content = this.content;\n        if (content && Util._isInDocument(content)) {\n            this.container().removeChild(content);\n        }\n        var index = stages.indexOf(this);\n        if (index > -1) {\n            stages.splice(index, 1);\n        }\n        return this;\n    }\n    getPointerPosition() {\n        const pos = this._pointerPositions[0] || this._changedPointerPositions[0];\n        if (!pos) {\n            Util.warn(NO_POINTERS_MESSAGE);\n            return null;\n        }\n        return {\n            x: pos.x,\n            y: pos.y,\n        };\n    }\n    _getPointerById(id) {\n        return this._pointerPositions.find((p) => p.id === id);\n    }\n    getPointersPositions() {\n        return this._pointerPositions;\n    }\n    getStage() {\n        return this;\n    }\n    getContent() {\n        return this.content;\n    }\n    _toKonvaCanvas(config) {\n        config = config || {};\n        config.x = config.x || 0;\n        config.y = config.y || 0;\n        config.width = config.width || this.width();\n        config.height = config.height || this.height();\n        var canvas = new SceneCanvas({\n            width: config.width,\n            height: config.height,\n            pixelRatio: config.pixelRatio || 1,\n        });\n        var _context = canvas.getContext()._context;\n        var layers = this.children;\n        if (config.x || config.y) {\n            _context.translate(-1 * config.x, -1 * config.y);\n        }\n        layers.forEach(function (layer) {\n            if (!layer.isVisible()) {\n                return;\n            }\n            var layerCanvas = layer._toKonvaCanvas(config);\n            _context.drawImage(layerCanvas._canvas, config.x, config.y, layerCanvas.getWidth() / layerCanvas.getPixelRatio(), layerCanvas.getHeight() / layerCanvas.getPixelRatio());\n        });\n        return canvas;\n    }\n    getIntersection(pos) {\n        if (!pos) {\n            return null;\n        }\n        var layers = this.children, len = layers.length, end = len - 1, n;\n        for (n = end; n >= 0; n--) {\n            const shape = layers[n].getIntersection(pos);\n            if (shape) {\n                return shape;\n            }\n        }\n        return null;\n    }\n    _resizeDOM() {\n        var width = this.width();\n        var height = this.height();\n        if (this.content) {\n            this.content.style.width = width + PX;\n            this.content.style.height = height + PX;\n        }\n        this.bufferCanvas.setSize(width, height);\n        this.bufferHitCanvas.setSize(width, height);\n        this.children.forEach((layer) => {\n            layer.setSize({ width, height });\n            layer.draw();\n        });\n    }\n    add(layer, ...rest) {\n        if (arguments.length > 1) {\n            for (var i = 0; i < arguments.length; i++) {\n                this.add(arguments[i]);\n            }\n            return this;\n        }\n        super.add(layer);\n        var length = this.children.length;\n        if (length > MAX_LAYERS_NUMBER) {\n            Util.warn('The stage has ' +\n                length +\n                ' layers. Recommended maximum number of layers is 3-5. Adding more layers into the stage may drop the performance. Rethink your tree structure, you can use Konva.Group.');\n        }\n        layer.setSize({ width: this.width(), height: this.height() });\n        layer.draw();\n        if (Konva.isBrowser) {\n            this.content.appendChild(layer.canvas._canvas);\n        }\n        return this;\n    }\n    getParent() {\n        return null;\n    }\n    getLayer() {\n        return null;\n    }\n    hasPointerCapture(pointerId) {\n        return PointerEvents.hasPointerCapture(pointerId, this);\n    }\n    setPointerCapture(pointerId) {\n        PointerEvents.setPointerCapture(pointerId, this);\n    }\n    releaseCapture(pointerId) {\n        PointerEvents.releaseCapture(pointerId, this);\n    }\n    getLayers() {\n        return this.children;\n    }\n    _bindContentEvents() {\n        if (!Konva.isBrowser) {\n            return;\n        }\n        EVENTS.forEach(([event, methodName]) => {\n            this.content.addEventListener(event, (evt) => {\n                this[methodName](evt);\n            });\n        });\n    }\n    _pointerenter(evt) {\n        this.setPointersPositions(evt);\n        const events = getEventsMap(evt.type);\n        this._fire(events.pointerenter, {\n            evt: evt,\n            target: this,\n            currentTarget: this,\n        });\n    }\n    _pointerover(evt) {\n        this.setPointersPositions(evt);\n        const events = getEventsMap(evt.type);\n        this._fire(events.pointerover, {\n            evt: evt,\n            target: this,\n            currentTarget: this,\n        });\n    }\n    _getTargetShape(evenType) {\n        let shape = this[evenType + 'targetShape'];\n        if (shape && !shape.getStage()) {\n            shape = null;\n        }\n        return shape;\n    }\n    _pointerleave(evt) {\n        const events = getEventsMap(evt.type);\n        const eventType = getEventType(evt.type);\n        if (!events) {\n            return;\n        }\n        this.setPointersPositions(evt);\n        var targetShape = this._getTargetShape(eventType);\n        var eventsEnabled = !DD.isDragging || Konva.hitOnDragEnabled;\n        if (targetShape && eventsEnabled) {\n            targetShape._fireAndBubble(events.pointerout, { evt: evt });\n            targetShape._fireAndBubble(events.pointerleave, { evt: evt });\n            this._fire(events.pointerleave, {\n                evt: evt,\n                target: this,\n                currentTarget: this,\n            });\n            this[eventType + 'targetShape'] = null;\n        }\n        else if (eventsEnabled) {\n            this._fire(events.pointerleave, {\n                evt: evt,\n                target: this,\n                currentTarget: this,\n            });\n            this._fire(events.pointerout, {\n                evt: evt,\n                target: this,\n                currentTarget: this,\n            });\n        }\n        this.pointerPos = undefined;\n        this._pointerPositions = [];\n    }\n    _pointerdown(evt) {\n        const events = getEventsMap(evt.type);\n        const eventType = getEventType(evt.type);\n        if (!events) {\n            return;\n        }\n        this.setPointersPositions(evt);\n        var triggeredOnShape = false;\n        this._changedPointerPositions.forEach((pos) => {\n            var shape = this.getIntersection(pos);\n            DD.justDragged = false;\n            Konva['_' + eventType + 'ListenClick'] = true;\n            const hasShape = shape && shape.isListening();\n            if (!hasShape) {\n                return;\n            }\n            if (Konva.capturePointerEventsEnabled) {\n                shape.setPointerCapture(pos.id);\n            }\n            this[eventType + 'ClickStartShape'] = shape;\n            shape._fireAndBubble(events.pointerdown, {\n                evt: evt,\n                pointerId: pos.id,\n            });\n            triggeredOnShape = true;\n            const isTouch = evt.type.indexOf('touch') >= 0;\n            if (shape.preventDefault() && evt.cancelable && isTouch) {\n                evt.preventDefault();\n            }\n        });\n        if (!triggeredOnShape) {\n            this._fire(events.pointerdown, {\n                evt: evt,\n                target: this,\n                currentTarget: this,\n                pointerId: this._pointerPositions[0].id,\n            });\n        }\n    }\n    _pointermove(evt) {\n        const events = getEventsMap(evt.type);\n        const eventType = getEventType(evt.type);\n        if (!events) {\n            return;\n        }\n        if (DD.isDragging && DD.node.preventDefault() && evt.cancelable) {\n            evt.preventDefault();\n        }\n        this.setPointersPositions(evt);\n        var eventsEnabled = !DD.isDragging || Konva.hitOnDragEnabled;\n        if (!eventsEnabled) {\n            return;\n        }\n        var processedShapesIds = {};\n        let triggeredOnShape = false;\n        var targetShape = this._getTargetShape(eventType);\n        this._changedPointerPositions.forEach((pos) => {\n            const shape = (PointerEvents.getCapturedShape(pos.id) ||\n                this.getIntersection(pos));\n            const pointerId = pos.id;\n            const event = { evt: evt, pointerId };\n            var differentTarget = targetShape !== shape;\n            if (differentTarget && targetShape) {\n                targetShape._fireAndBubble(events.pointerout, Object.assign({}, event), shape);\n                targetShape._fireAndBubble(events.pointerleave, Object.assign({}, event), shape);\n            }\n            if (shape) {\n                if (processedShapesIds[shape._id]) {\n                    return;\n                }\n                processedShapesIds[shape._id] = true;\n            }\n            if (shape && shape.isListening()) {\n                triggeredOnShape = true;\n                if (differentTarget) {\n                    shape._fireAndBubble(events.pointerover, Object.assign({}, event), targetShape);\n                    shape._fireAndBubble(events.pointerenter, Object.assign({}, event), targetShape);\n                    this[eventType + 'targetShape'] = shape;\n                }\n                shape._fireAndBubble(events.pointermove, Object.assign({}, event));\n            }\n            else {\n                if (targetShape) {\n                    this._fire(events.pointerover, {\n                        evt: evt,\n                        target: this,\n                        currentTarget: this,\n                        pointerId,\n                    });\n                    this[eventType + 'targetShape'] = null;\n                }\n            }\n        });\n        if (!triggeredOnShape) {\n            this._fire(events.pointermove, {\n                evt: evt,\n                target: this,\n                currentTarget: this,\n                pointerId: this._changedPointerPositions[0].id,\n            });\n        }\n    }\n    _pointerup(evt) {\n        const events = getEventsMap(evt.type);\n        const eventType = getEventType(evt.type);\n        if (!events) {\n            return;\n        }\n        this.setPointersPositions(evt);\n        const clickStartShape = this[eventType + 'ClickStartShape'];\n        const clickEndShape = this[eventType + 'ClickEndShape'];\n        var processedShapesIds = {};\n        let triggeredOnShape = false;\n        this._changedPointerPositions.forEach((pos) => {\n            const shape = (PointerEvents.getCapturedShape(pos.id) ||\n                this.getIntersection(pos));\n            if (shape) {\n                shape.releaseCapture(pos.id);\n                if (processedShapesIds[shape._id]) {\n                    return;\n                }\n                processedShapesIds[shape._id] = true;\n            }\n            const pointerId = pos.id;\n            const event = { evt: evt, pointerId };\n            let fireDblClick = false;\n            if (Konva['_' + eventType + 'InDblClickWindow']) {\n                fireDblClick = true;\n                clearTimeout(this[eventType + 'DblTimeout']);\n            }\n            else if (!DD.justDragged) {\n                Konva['_' + eventType + 'InDblClickWindow'] = true;\n                clearTimeout(this[eventType + 'DblTimeout']);\n            }\n            this[eventType + 'DblTimeout'] = setTimeout(function () {\n                Konva['_' + eventType + 'InDblClickWindow'] = false;\n            }, Konva.dblClickWindow);\n            if (shape && shape.isListening()) {\n                triggeredOnShape = true;\n                this[eventType + 'ClickEndShape'] = shape;\n                shape._fireAndBubble(events.pointerup, Object.assign({}, event));\n                if (Konva['_' + eventType + 'ListenClick'] &&\n                    clickStartShape &&\n                    clickStartShape === shape) {\n                    shape._fireAndBubble(events.pointerclick, Object.assign({}, event));\n                    if (fireDblClick && clickEndShape && clickEndShape === shape) {\n                        shape._fireAndBubble(events.pointerdblclick, Object.assign({}, event));\n                    }\n                }\n            }\n            else {\n                this[eventType + 'ClickEndShape'] = null;\n                if (Konva['_' + eventType + 'ListenClick']) {\n                    this._fire(events.pointerclick, {\n                        evt: evt,\n                        target: this,\n                        currentTarget: this,\n                        pointerId,\n                    });\n                }\n                if (fireDblClick) {\n                    this._fire(events.pointerdblclick, {\n                        evt: evt,\n                        target: this,\n                        currentTarget: this,\n                        pointerId,\n                    });\n                }\n            }\n        });\n        if (!triggeredOnShape) {\n            this._fire(events.pointerup, {\n                evt: evt,\n                target: this,\n                currentTarget: this,\n                pointerId: this._changedPointerPositions[0].id,\n            });\n        }\n        Konva['_' + eventType + 'ListenClick'] = false;\n        if (evt.cancelable) {\n            evt.preventDefault();\n        }\n    }\n    _contextmenu(evt) {\n        this.setPointersPositions(evt);\n        var shape = this.getIntersection(this.getPointerPosition());\n        if (shape && shape.isListening()) {\n            shape._fireAndBubble(CONTEXTMENU, { evt: evt });\n        }\n        else {\n            this._fire(CONTEXTMENU, {\n                evt: evt,\n                target: this,\n                currentTarget: this,\n            });\n        }\n    }\n    _wheel(evt) {\n        this.setPointersPositions(evt);\n        var shape = this.getIntersection(this.getPointerPosition());\n        if (shape && shape.isListening()) {\n            shape._fireAndBubble(WHEEL, { evt: evt });\n        }\n        else {\n            this._fire(WHEEL, {\n                evt: evt,\n                target: this,\n                currentTarget: this,\n            });\n        }\n    }\n    _pointercancel(evt) {\n        this.setPointersPositions(evt);\n        const shape = PointerEvents.getCapturedShape(evt.pointerId) ||\n            this.getIntersection(this.getPointerPosition());\n        if (shape) {\n            shape._fireAndBubble(POINTERUP, PointerEvents.createEvent(evt));\n        }\n        PointerEvents.releaseCapture(evt.pointerId);\n    }\n    _lostpointercapture(evt) {\n        PointerEvents.releaseCapture(evt.pointerId);\n    }\n    setPointersPositions(evt) {\n        var contentPosition = this._getContentPosition(), x = null, y = null;\n        evt = evt ? evt : window.event;\n        if (evt.touches !== undefined) {\n            this._pointerPositions = [];\n            this._changedPointerPositions = [];\n            Array.prototype.forEach.call(evt.touches, (touch) => {\n                this._pointerPositions.push({\n                    id: touch.identifier,\n                    x: (touch.clientX - contentPosition.left) / contentPosition.scaleX,\n                    y: (touch.clientY - contentPosition.top) / contentPosition.scaleY,\n                });\n            });\n            Array.prototype.forEach.call(evt.changedTouches || evt.touches, (touch) => {\n                this._changedPointerPositions.push({\n                    id: touch.identifier,\n                    x: (touch.clientX - contentPosition.left) / contentPosition.scaleX,\n                    y: (touch.clientY - contentPosition.top) / contentPosition.scaleY,\n                });\n            });\n        }\n        else {\n            x = (evt.clientX - contentPosition.left) / contentPosition.scaleX;\n            y = (evt.clientY - contentPosition.top) / contentPosition.scaleY;\n            this.pointerPos = {\n                x: x,\n                y: y,\n            };\n            this._pointerPositions = [{ x, y, id: Util._getFirstPointerId(evt) }];\n            this._changedPointerPositions = [\n                { x, y, id: Util._getFirstPointerId(evt) },\n            ];\n        }\n    }\n    _setPointerPosition(evt) {\n        Util.warn('Method _setPointerPosition is deprecated. Use \"stage.setPointersPositions(event)\" instead.');\n        this.setPointersPositions(evt);\n    }\n    _getContentPosition() {\n        if (!this.content || !this.content.getBoundingClientRect) {\n            return {\n                top: 0,\n                left: 0,\n                scaleX: 1,\n                scaleY: 1,\n            };\n        }\n        var rect = this.content.getBoundingClientRect();\n        return {\n            top: rect.top,\n            left: rect.left,\n            scaleX: rect.width / this.content.clientWidth || 1,\n            scaleY: rect.height / this.content.clientHeight || 1,\n        };\n    }\n    _buildDOM() {\n        this.bufferCanvas = new SceneCanvas({\n            width: this.width(),\n            height: this.height(),\n        });\n        this.bufferHitCanvas = new HitCanvas({\n            pixelRatio: 1,\n            width: this.width(),\n            height: this.height(),\n        });\n        if (!Konva.isBrowser) {\n            return;\n        }\n        var container = this.container();\n        if (!container) {\n            throw 'Stage has no container. A container is required.';\n        }\n        container.innerHTML = '';\n        this.content = document.createElement('div');\n        this.content.style.position = 'relative';\n        this.content.style.userSelect = 'none';\n        this.content.className = 'konvajs-content';\n        this.content.setAttribute('role', 'presentation');\n        container.appendChild(this.content);\n        this._resizeDOM();\n    }\n    cache() {\n        Util.warn('Cache function is not allowed for stage. You may use cache only for layers, groups and shapes.');\n        return this;\n    }\n    clearCache() {\n        return this;\n    }\n    batchDraw() {\n        this.getChildren().forEach(function (layer) {\n            layer.batchDraw();\n        });\n        return this;\n    }\n}\nStage.prototype.nodeType = STAGE;\n_registerNode(Stage);\nFactory.addGetterSetter(Stage, 'container');\n//# sourceMappingURL=Stage.js.map"]},"metadata":{},"sourceType":"module"}