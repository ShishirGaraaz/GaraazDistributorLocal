{"ast":null,"code":"import { Konva } from './Global.js';\nimport { Transform, Util } from './Util.js';\nimport { Factory } from './Factory.js';\nimport { Node } from './Node.js';\nimport { getNumberValidator, getNumberOrAutoValidator, getStringValidator, getBooleanValidator, getStringOrGradientValidator } from './Validators.js';\nimport { _registerNode } from './Global.js';\nimport * as PointerEvents from './PointerEvents.js';\nvar HAS_SHADOW = 'hasShadow';\nvar SHADOW_RGBA = 'shadowRGBA';\nvar patternImage = 'patternImage';\nvar linearGradient = 'linearGradient';\nvar radialGradient = 'radialGradient';\nlet dummyContext;\n\nfunction getDummyContext() {\n  if (dummyContext) {\n    return dummyContext;\n  }\n\n  dummyContext = Util.createCanvasElement().getContext('2d');\n  return dummyContext;\n}\n\nexport const shapes = {};\n\nfunction _fillFunc(context) {\n  context.fill();\n}\n\nfunction _strokeFunc(context) {\n  context.stroke();\n}\n\nfunction _fillFuncHit(context) {\n  context.fill();\n}\n\nfunction _strokeFuncHit(context) {\n  context.stroke();\n}\n\nfunction _clearHasShadowCache() {\n  this._clearCache(HAS_SHADOW);\n}\n\nfunction _clearGetShadowRGBACache() {\n  this._clearCache(SHADOW_RGBA);\n}\n\nfunction _clearFillPatternCache() {\n  this._clearCache(patternImage);\n}\n\nfunction _clearLinearGradientCache() {\n  this._clearCache(linearGradient);\n}\n\nfunction _clearRadialGradientCache() {\n  this._clearCache(radialGradient);\n}\n\nexport class Shape extends Node {\n  constructor(config) {\n    super(config);\n    let key;\n\n    while (true) {\n      key = Util.getRandomColor();\n\n      if (key && !(key in shapes)) {\n        break;\n      }\n    }\n\n    this.colorKey = key;\n    shapes[key] = this;\n  }\n\n  getContext() {\n    Util.warn('shape.getContext() method is deprecated. Please do not use it.');\n    return this.getLayer().getContext();\n  }\n\n  getCanvas() {\n    Util.warn('shape.getCanvas() method is deprecated. Please do not use it.');\n    return this.getLayer().getCanvas();\n  }\n\n  getSceneFunc() {\n    return this.attrs.sceneFunc || this['_sceneFunc'];\n  }\n\n  getHitFunc() {\n    return this.attrs.hitFunc || this['_hitFunc'];\n  }\n\n  hasShadow() {\n    return this._getCache(HAS_SHADOW, this._hasShadow);\n  }\n\n  _hasShadow() {\n    return this.shadowEnabled() && this.shadowOpacity() !== 0 && !!(this.shadowColor() || this.shadowBlur() || this.shadowOffsetX() || this.shadowOffsetY());\n  }\n\n  _getFillPattern() {\n    return this._getCache(patternImage, this.__getFillPattern);\n  }\n\n  __getFillPattern() {\n    if (this.fillPatternImage()) {\n      var ctx = getDummyContext();\n      const pattern = ctx.createPattern(this.fillPatternImage(), this.fillPatternRepeat() || 'repeat');\n\n      if (pattern && pattern.setTransform) {\n        const tr = new Transform();\n        tr.translate(this.fillPatternX(), this.fillPatternY());\n        tr.rotate(Konva.getAngle(this.fillPatternRotation()));\n        tr.scale(this.fillPatternScaleX(), this.fillPatternScaleY());\n        tr.translate(-1 * this.fillPatternOffsetX(), -1 * this.fillPatternOffsetY());\n        const m = tr.getMatrix();\n        pattern.setTransform({\n          a: m[0],\n          b: m[1],\n          c: m[2],\n          d: m[3],\n          e: m[4],\n          f: m[5]\n        });\n      }\n\n      return pattern;\n    }\n  }\n\n  _getLinearGradient() {\n    return this._getCache(linearGradient, this.__getLinearGradient);\n  }\n\n  __getLinearGradient() {\n    var colorStops = this.fillLinearGradientColorStops();\n\n    if (colorStops) {\n      var ctx = getDummyContext();\n      var start = this.fillLinearGradientStartPoint();\n      var end = this.fillLinearGradientEndPoint();\n      var grd = ctx.createLinearGradient(start.x, start.y, end.x, end.y);\n\n      for (var n = 0; n < colorStops.length; n += 2) {\n        grd.addColorStop(colorStops[n], colorStops[n + 1]);\n      }\n\n      return grd;\n    }\n  }\n\n  _getRadialGradient() {\n    return this._getCache(radialGradient, this.__getRadialGradient);\n  }\n\n  __getRadialGradient() {\n    var colorStops = this.fillRadialGradientColorStops();\n\n    if (colorStops) {\n      var ctx = getDummyContext();\n      var start = this.fillRadialGradientStartPoint();\n      var end = this.fillRadialGradientEndPoint();\n      var grd = ctx.createRadialGradient(start.x, start.y, this.fillRadialGradientStartRadius(), end.x, end.y, this.fillRadialGradientEndRadius());\n\n      for (var n = 0; n < colorStops.length; n += 2) {\n        grd.addColorStop(colorStops[n], colorStops[n + 1]);\n      }\n\n      return grd;\n    }\n  }\n\n  getShadowRGBA() {\n    return this._getCache(SHADOW_RGBA, this._getShadowRGBA);\n  }\n\n  _getShadowRGBA() {\n    if (this.hasShadow()) {\n      var rgba = Util.colorToRGBA(this.shadowColor());\n      return 'rgba(' + rgba.r + ',' + rgba.g + ',' + rgba.b + ',' + rgba.a * (this.shadowOpacity() || 1) + ')';\n    }\n  }\n\n  hasFill() {\n    return this._calculate('hasFill', ['fillEnabled', 'fill', 'fillPatternImage', 'fillLinearGradientColorStops', 'fillRadialGradientColorStops'], () => {\n      return this.fillEnabled() && !!(this.fill() || this.fillPatternImage() || this.fillLinearGradientColorStops() || this.fillRadialGradientColorStops());\n    });\n  }\n\n  hasStroke() {\n    return this._calculate('hasStroke', ['strokeEnabled', 'strokeWidth', 'stroke', 'strokeLinearGradientColorStops'], () => {\n      return this.strokeEnabled() && this.strokeWidth() && !!(this.stroke() || this.strokeLinearGradientColorStops());\n    });\n  }\n\n  hasHitStroke() {\n    const width = this.hitStrokeWidth();\n\n    if (width === 'auto') {\n      return this.hasStroke();\n    }\n\n    return this.strokeEnabled() && !!width;\n  }\n\n  intersects(point) {\n    var stage = this.getStage(),\n        bufferHitCanvas = stage.bufferHitCanvas,\n        p;\n    bufferHitCanvas.getContext().clear();\n    this.drawHit(bufferHitCanvas, null, true);\n    p = bufferHitCanvas.context.getImageData(Math.round(point.x), Math.round(point.y), 1, 1).data;\n    return p[3] > 0;\n  }\n\n  destroy() {\n    Node.prototype.destroy.call(this);\n    delete shapes[this.colorKey];\n    delete this.colorKey;\n    return this;\n  }\n\n  _useBufferCanvas(forceFill) {\n    var _a;\n\n    if (!this.getStage()) {\n      return false;\n    }\n\n    const perfectDrawEnabled = (_a = this.attrs.perfectDrawEnabled) !== null && _a !== void 0 ? _a : true;\n\n    if (!perfectDrawEnabled) {\n      return false;\n    }\n\n    const hasFill = forceFill || this.hasFill();\n    const hasStroke = this.hasStroke();\n    const isTransparent = this.getAbsoluteOpacity() !== 1;\n\n    if (hasFill && hasStroke && isTransparent) {\n      return true;\n    }\n\n    const hasShadow = this.hasShadow();\n    const strokeForShadow = this.shadowForStrokeEnabled();\n\n    if (hasFill && hasStroke && hasShadow && strokeForShadow) {\n      return true;\n    }\n\n    return false;\n  }\n\n  setStrokeHitEnabled(val) {\n    Util.warn('strokeHitEnabled property is deprecated. Please use hitStrokeWidth instead.');\n\n    if (val) {\n      this.hitStrokeWidth('auto');\n    } else {\n      this.hitStrokeWidth(0);\n    }\n  }\n\n  getStrokeHitEnabled() {\n    if (this.hitStrokeWidth() === 0) {\n      return false;\n    } else {\n      return true;\n    }\n  }\n\n  getSelfRect() {\n    var size = this.size();\n    return {\n      x: this._centroid ? -size.width / 2 : 0,\n      y: this._centroid ? -size.height / 2 : 0,\n      width: size.width,\n      height: size.height\n    };\n  }\n\n  getClientRect() {\n    let config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const skipTransform = config.skipTransform;\n    const relativeTo = config.relativeTo;\n    const fillRect = this.getSelfRect();\n    const applyStroke = !config.skipStroke && this.hasStroke();\n    const strokeWidth = applyStroke && this.strokeWidth() || 0;\n    const fillAndStrokeWidth = fillRect.width + strokeWidth;\n    const fillAndStrokeHeight = fillRect.height + strokeWidth;\n    const applyShadow = !config.skipShadow && this.hasShadow();\n    const shadowOffsetX = applyShadow ? this.shadowOffsetX() : 0;\n    const shadowOffsetY = applyShadow ? this.shadowOffsetY() : 0;\n    const preWidth = fillAndStrokeWidth + Math.abs(shadowOffsetX);\n    const preHeight = fillAndStrokeHeight + Math.abs(shadowOffsetY);\n    const blurRadius = applyShadow && this.shadowBlur() || 0;\n    const width = preWidth + blurRadius * 2;\n    const height = preHeight + blurRadius * 2;\n    let roundingOffset = 0;\n\n    if (Math.round(strokeWidth / 2) !== strokeWidth / 2) {\n      roundingOffset = 1;\n    }\n\n    const rect = {\n      width: width + roundingOffset,\n      height: height + roundingOffset,\n      x: -Math.round(strokeWidth / 2 + blurRadius) + Math.min(shadowOffsetX, 0) + fillRect.x,\n      y: -Math.round(strokeWidth / 2 + blurRadius) + Math.min(shadowOffsetY, 0) + fillRect.y\n    };\n\n    if (!skipTransform) {\n      return this._transformedRect(rect, relativeTo);\n    }\n\n    return rect;\n  }\n\n  drawScene(can, top) {\n    var layer = this.getLayer(),\n        canvas = can || layer.getCanvas(),\n        context = canvas.getContext(),\n        cachedCanvas = this._getCanvasCache(),\n        drawFunc = this.getSceneFunc(),\n        hasShadow = this.hasShadow(),\n        stage,\n        bufferCanvas,\n        bufferContext;\n\n    var skipBuffer = canvas.isCache;\n    var cachingSelf = top === this;\n\n    if (!this.isVisible() && !cachingSelf) {\n      return this;\n    }\n\n    if (cachedCanvas) {\n      context.save();\n      var m = this.getAbsoluteTransform(top).getMatrix();\n      context.transform(m[0], m[1], m[2], m[3], m[4], m[5]);\n\n      this._drawCachedSceneCanvas(context);\n\n      context.restore();\n      return this;\n    }\n\n    if (!drawFunc) {\n      return this;\n    }\n\n    context.save();\n\n    if (this._useBufferCanvas() && !skipBuffer) {\n      stage = this.getStage();\n      bufferCanvas = stage.bufferCanvas;\n      bufferContext = bufferCanvas.getContext();\n      bufferContext.clear();\n      bufferContext.save();\n\n      bufferContext._applyLineJoin(this);\n\n      var o = this.getAbsoluteTransform(top).getMatrix();\n      bufferContext.transform(o[0], o[1], o[2], o[3], o[4], o[5]);\n      drawFunc.call(this, bufferContext, this);\n      bufferContext.restore();\n      var ratio = bufferCanvas.pixelRatio;\n\n      if (hasShadow) {\n        context._applyShadow(this);\n      }\n\n      context._applyOpacity(this);\n\n      context._applyGlobalCompositeOperation(this);\n\n      context.drawImage(bufferCanvas._canvas, 0, 0, bufferCanvas.width / ratio, bufferCanvas.height / ratio);\n    } else {\n      context._applyLineJoin(this);\n\n      if (!cachingSelf) {\n        var o = this.getAbsoluteTransform(top).getMatrix();\n        context.transform(o[0], o[1], o[2], o[3], o[4], o[5]);\n\n        context._applyOpacity(this);\n\n        context._applyGlobalCompositeOperation(this);\n      }\n\n      if (hasShadow) {\n        context._applyShadow(this);\n      }\n\n      drawFunc.call(this, context, this);\n    }\n\n    context.restore();\n    return this;\n  }\n\n  drawHit(can, top) {\n    let skipDragCheck = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n    if (!this.shouldDrawHit(top, skipDragCheck)) {\n      return this;\n    }\n\n    var layer = this.getLayer(),\n        canvas = can || layer.hitCanvas,\n        context = canvas && canvas.getContext(),\n        drawFunc = this.hitFunc() || this.sceneFunc(),\n        cachedCanvas = this._getCanvasCache(),\n        cachedHitCanvas = cachedCanvas && cachedCanvas.hit;\n\n    if (!this.colorKey) {\n      Util.warn('Looks like your canvas has a destroyed shape in it. Do not reuse shape after you destroyed it. If you want to reuse shape you should call remove() instead of destroy()');\n    }\n\n    if (cachedHitCanvas) {\n      context.save();\n      var m = this.getAbsoluteTransform(top).getMatrix();\n      context.transform(m[0], m[1], m[2], m[3], m[4], m[5]);\n\n      this._drawCachedHitCanvas(context);\n\n      context.restore();\n      return this;\n    }\n\n    if (!drawFunc) {\n      return this;\n    }\n\n    context.save();\n\n    context._applyLineJoin(this);\n\n    const selfCache = this === top;\n\n    if (!selfCache) {\n      var o = this.getAbsoluteTransform(top).getMatrix();\n      context.transform(o[0], o[1], o[2], o[3], o[4], o[5]);\n    }\n\n    drawFunc.call(this, context, this);\n    context.restore();\n    return this;\n  }\n\n  drawHitFromCache() {\n    let alphaThreshold = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\n    var cachedCanvas = this._getCanvasCache(),\n        sceneCanvas = this._getCachedSceneCanvas(),\n        hitCanvas = cachedCanvas.hit,\n        hitContext = hitCanvas.getContext(),\n        hitWidth = hitCanvas.getWidth(),\n        hitHeight = hitCanvas.getHeight(),\n        hitImageData,\n        hitData,\n        len,\n        rgbColorKey,\n        i,\n        alpha;\n\n    hitContext.clear();\n    hitContext.drawImage(sceneCanvas._canvas, 0, 0, hitWidth, hitHeight);\n\n    try {\n      hitImageData = hitContext.getImageData(0, 0, hitWidth, hitHeight);\n      hitData = hitImageData.data;\n      len = hitData.length;\n      rgbColorKey = Util._hexToRgb(this.colorKey);\n\n      for (i = 0; i < len; i += 4) {\n        alpha = hitData[i + 3];\n\n        if (alpha > alphaThreshold) {\n          hitData[i] = rgbColorKey.r;\n          hitData[i + 1] = rgbColorKey.g;\n          hitData[i + 2] = rgbColorKey.b;\n          hitData[i + 3] = 255;\n        } else {\n          hitData[i + 3] = 0;\n        }\n      }\n\n      hitContext.putImageData(hitImageData, 0, 0);\n    } catch (e) {\n      Util.error('Unable to draw hit graph from cached scene canvas. ' + e.message);\n    }\n\n    return this;\n  }\n\n  hasPointerCapture(pointerId) {\n    return PointerEvents.hasPointerCapture(pointerId, this);\n  }\n\n  setPointerCapture(pointerId) {\n    PointerEvents.setPointerCapture(pointerId, this);\n  }\n\n  releaseCapture(pointerId) {\n    PointerEvents.releaseCapture(pointerId, this);\n  }\n\n}\nShape.prototype._fillFunc = _fillFunc;\nShape.prototype._strokeFunc = _strokeFunc;\nShape.prototype._fillFuncHit = _fillFuncHit;\nShape.prototype._strokeFuncHit = _strokeFuncHit;\nShape.prototype._centroid = false;\nShape.prototype.nodeType = 'Shape';\n\n_registerNode(Shape);\n\nShape.prototype.eventListeners = {};\nShape.prototype.on.call(Shape.prototype, 'shadowColorChange.konva shadowBlurChange.konva shadowOffsetChange.konva shadowOpacityChange.konva shadowEnabledChange.konva', _clearHasShadowCache);\nShape.prototype.on.call(Shape.prototype, 'shadowColorChange.konva shadowOpacityChange.konva shadowEnabledChange.konva', _clearGetShadowRGBACache);\nShape.prototype.on.call(Shape.prototype, 'fillPriorityChange.konva fillPatternImageChange.konva fillPatternRepeatChange.konva fillPatternScaleXChange.konva fillPatternScaleYChange.konva fillPatternOffsetXChange.konva fillPatternOffsetYChange.konva fillPatternXChange.konva fillPatternYChange.konva fillPatternRotationChange.konva', _clearFillPatternCache);\nShape.prototype.on.call(Shape.prototype, 'fillPriorityChange.konva fillLinearGradientColorStopsChange.konva fillLinearGradientStartPointXChange.konva fillLinearGradientStartPointYChange.konva fillLinearGradientEndPointXChange.konva fillLinearGradientEndPointYChange.konva', _clearLinearGradientCache);\nShape.prototype.on.call(Shape.prototype, 'fillPriorityChange.konva fillRadialGradientColorStopsChange.konva fillRadialGradientStartPointXChange.konva fillRadialGradientStartPointYChange.konva fillRadialGradientEndPointXChange.konva fillRadialGradientEndPointYChange.konva fillRadialGradientStartRadiusChange.konva fillRadialGradientEndRadiusChange.konva', _clearRadialGradientCache);\nFactory.addGetterSetter(Shape, 'stroke', undefined, getStringOrGradientValidator());\nFactory.addGetterSetter(Shape, 'strokeWidth', 2, getNumberValidator());\nFactory.addGetterSetter(Shape, 'fillAfterStrokeEnabled', false);\nFactory.addGetterSetter(Shape, 'hitStrokeWidth', 'auto', getNumberOrAutoValidator());\nFactory.addGetterSetter(Shape, 'strokeHitEnabled', true, getBooleanValidator());\nFactory.addGetterSetter(Shape, 'perfectDrawEnabled', true, getBooleanValidator());\nFactory.addGetterSetter(Shape, 'shadowForStrokeEnabled', true, getBooleanValidator());\nFactory.addGetterSetter(Shape, 'lineJoin');\nFactory.addGetterSetter(Shape, 'lineCap');\nFactory.addGetterSetter(Shape, 'sceneFunc');\nFactory.addGetterSetter(Shape, 'hitFunc');\nFactory.addGetterSetter(Shape, 'dash');\nFactory.addGetterSetter(Shape, 'dashOffset', 0, getNumberValidator());\nFactory.addGetterSetter(Shape, 'shadowColor', undefined, getStringValidator());\nFactory.addGetterSetter(Shape, 'shadowBlur', 0, getNumberValidator());\nFactory.addGetterSetter(Shape, 'shadowOpacity', 1, getNumberValidator());\nFactory.addComponentsGetterSetter(Shape, 'shadowOffset', ['x', 'y']);\nFactory.addGetterSetter(Shape, 'shadowOffsetX', 0, getNumberValidator());\nFactory.addGetterSetter(Shape, 'shadowOffsetY', 0, getNumberValidator());\nFactory.addGetterSetter(Shape, 'fillPatternImage');\nFactory.addGetterSetter(Shape, 'fill', undefined, getStringOrGradientValidator());\nFactory.addGetterSetter(Shape, 'fillPatternX', 0, getNumberValidator());\nFactory.addGetterSetter(Shape, 'fillPatternY', 0, getNumberValidator());\nFactory.addGetterSetter(Shape, 'fillLinearGradientColorStops');\nFactory.addGetterSetter(Shape, 'strokeLinearGradientColorStops');\nFactory.addGetterSetter(Shape, 'fillRadialGradientStartRadius', 0);\nFactory.addGetterSetter(Shape, 'fillRadialGradientEndRadius', 0);\nFactory.addGetterSetter(Shape, 'fillRadialGradientColorStops');\nFactory.addGetterSetter(Shape, 'fillPatternRepeat', 'repeat');\nFactory.addGetterSetter(Shape, 'fillEnabled', true);\nFactory.addGetterSetter(Shape, 'strokeEnabled', true);\nFactory.addGetterSetter(Shape, 'shadowEnabled', true);\nFactory.addGetterSetter(Shape, 'dashEnabled', true);\nFactory.addGetterSetter(Shape, 'strokeScaleEnabled', true);\nFactory.addGetterSetter(Shape, 'fillPriority', 'color');\nFactory.addComponentsGetterSetter(Shape, 'fillPatternOffset', ['x', 'y']);\nFactory.addGetterSetter(Shape, 'fillPatternOffsetX', 0, getNumberValidator());\nFactory.addGetterSetter(Shape, 'fillPatternOffsetY', 0, getNumberValidator());\nFactory.addComponentsGetterSetter(Shape, 'fillPatternScale', ['x', 'y']);\nFactory.addGetterSetter(Shape, 'fillPatternScaleX', 1, getNumberValidator());\nFactory.addGetterSetter(Shape, 'fillPatternScaleY', 1, getNumberValidator());\nFactory.addComponentsGetterSetter(Shape, 'fillLinearGradientStartPoint', ['x', 'y']);\nFactory.addComponentsGetterSetter(Shape, 'strokeLinearGradientStartPoint', ['x', 'y']);\nFactory.addGetterSetter(Shape, 'fillLinearGradientStartPointX', 0);\nFactory.addGetterSetter(Shape, 'strokeLinearGradientStartPointX', 0);\nFactory.addGetterSetter(Shape, 'fillLinearGradientStartPointY', 0);\nFactory.addGetterSetter(Shape, 'strokeLinearGradientStartPointY', 0);\nFactory.addComponentsGetterSetter(Shape, 'fillLinearGradientEndPoint', ['x', 'y']);\nFactory.addComponentsGetterSetter(Shape, 'strokeLinearGradientEndPoint', ['x', 'y']);\nFactory.addGetterSetter(Shape, 'fillLinearGradientEndPointX', 0);\nFactory.addGetterSetter(Shape, 'strokeLinearGradientEndPointX', 0);\nFactory.addGetterSetter(Shape, 'fillLinearGradientEndPointY', 0);\nFactory.addGetterSetter(Shape, 'strokeLinearGradientEndPointY', 0);\nFactory.addComponentsGetterSetter(Shape, 'fillRadialGradientStartPoint', ['x', 'y']);\nFactory.addGetterSetter(Shape, 'fillRadialGradientStartPointX', 0);\nFactory.addGetterSetter(Shape, 'fillRadialGradientStartPointY', 0);\nFactory.addComponentsGetterSetter(Shape, 'fillRadialGradientEndPoint', ['x', 'y']);\nFactory.addGetterSetter(Shape, 'fillRadialGradientEndPointX', 0);\nFactory.addGetterSetter(Shape, 'fillRadialGradientEndPointY', 0);\nFactory.addGetterSetter(Shape, 'fillPatternRotation', 0);\nFactory.backCompat(Shape, {\n  dashArray: 'dash',\n  getDashArray: 'getDash',\n  setDashArray: 'getDash',\n  drawFunc: 'sceneFunc',\n  getDrawFunc: 'getSceneFunc',\n  setDrawFunc: 'setSceneFunc',\n  drawHitFunc: 'hitFunc',\n  getDrawHitFunc: 'getHitFunc',\n  setDrawHitFunc: 'setHitFunc'\n});","map":{"version":3,"sources":["../src/Shape.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { Konva } from './Global.js';\nimport { Transform, Util } from './Util.js';\nimport { Factory } from './Factory.js';\nimport { Node } from './Node.js';\nimport { getNumberValidator, getNumberOrAutoValidator, getStringValidator, getBooleanValidator, getStringOrGradientValidator, } from './Validators.js';\nimport { _registerNode } from './Global.js';\nimport * as PointerEvents from './PointerEvents.js';\nvar HAS_SHADOW = 'hasShadow';\nvar SHADOW_RGBA = 'shadowRGBA';\nvar patternImage = 'patternImage';\nvar linearGradient = 'linearGradient';\nvar radialGradient = 'radialGradient';\nlet dummyContext;\nfunction getDummyContext() {\n    if (dummyContext) {\n        return dummyContext;\n    }\n    dummyContext = Util.createCanvasElement().getContext('2d');\n    return dummyContext;\n}\nexport const shapes = {};\nfunction _fillFunc(context) {\n    context.fill();\n}\nfunction _strokeFunc(context) {\n    context.stroke();\n}\nfunction _fillFuncHit(context) {\n    context.fill();\n}\nfunction _strokeFuncHit(context) {\n    context.stroke();\n}\nfunction _clearHasShadowCache() {\n    this._clearCache(HAS_SHADOW);\n}\nfunction _clearGetShadowRGBACache() {\n    this._clearCache(SHADOW_RGBA);\n}\nfunction _clearFillPatternCache() {\n    this._clearCache(patternImage);\n}\nfunction _clearLinearGradientCache() {\n    this._clearCache(linearGradient);\n}\nfunction _clearRadialGradientCache() {\n    this._clearCache(radialGradient);\n}\nexport class Shape extends Node {\n    constructor(config) {\n        super(config);\n        let key;\n        while (true) {\n            key = Util.getRandomColor();\n            if (key && !(key in shapes)) {\n                break;\n            }\n        }\n        this.colorKey = key;\n        shapes[key] = this;\n    }\n    getContext() {\n        Util.warn('shape.getContext() method is deprecated. Please do not use it.');\n        return this.getLayer().getContext();\n    }\n    getCanvas() {\n        Util.warn('shape.getCanvas() method is deprecated. Please do not use it.');\n        return this.getLayer().getCanvas();\n    }\n    getSceneFunc() {\n        return this.attrs.sceneFunc || this['_sceneFunc'];\n    }\n    getHitFunc() {\n        return this.attrs.hitFunc || this['_hitFunc'];\n    }\n    hasShadow() {\n        return this._getCache(HAS_SHADOW, this._hasShadow);\n    }\n    _hasShadow() {\n        return (this.shadowEnabled() &&\n            this.shadowOpacity() !== 0 &&\n            !!(this.shadowColor() ||\n                this.shadowBlur() ||\n                this.shadowOffsetX() ||\n                this.shadowOffsetY()));\n    }\n    _getFillPattern() {\n        return this._getCache(patternImage, this.__getFillPattern);\n    }\n    __getFillPattern() {\n        if (this.fillPatternImage()) {\n            var ctx = getDummyContext();\n            const pattern = ctx.createPattern(this.fillPatternImage(), this.fillPatternRepeat() || 'repeat');\n            if (pattern && pattern.setTransform) {\n                const tr = new Transform();\n                tr.translate(this.fillPatternX(), this.fillPatternY());\n                tr.rotate(Konva.getAngle(this.fillPatternRotation()));\n                tr.scale(this.fillPatternScaleX(), this.fillPatternScaleY());\n                tr.translate(-1 * this.fillPatternOffsetX(), -1 * this.fillPatternOffsetY());\n                const m = tr.getMatrix();\n                pattern.setTransform({\n                    a: m[0],\n                    b: m[1],\n                    c: m[2],\n                    d: m[3],\n                    e: m[4],\n                    f: m[5],\n                });\n            }\n            return pattern;\n        }\n    }\n    _getLinearGradient() {\n        return this._getCache(linearGradient, this.__getLinearGradient);\n    }\n    __getLinearGradient() {\n        var colorStops = this.fillLinearGradientColorStops();\n        if (colorStops) {\n            var ctx = getDummyContext();\n            var start = this.fillLinearGradientStartPoint();\n            var end = this.fillLinearGradientEndPoint();\n            var grd = ctx.createLinearGradient(start.x, start.y, end.x, end.y);\n            for (var n = 0; n < colorStops.length; n += 2) {\n                grd.addColorStop(colorStops[n], colorStops[n + 1]);\n            }\n            return grd;\n        }\n    }\n    _getRadialGradient() {\n        return this._getCache(radialGradient, this.__getRadialGradient);\n    }\n    __getRadialGradient() {\n        var colorStops = this.fillRadialGradientColorStops();\n        if (colorStops) {\n            var ctx = getDummyContext();\n            var start = this.fillRadialGradientStartPoint();\n            var end = this.fillRadialGradientEndPoint();\n            var grd = ctx.createRadialGradient(start.x, start.y, this.fillRadialGradientStartRadius(), end.x, end.y, this.fillRadialGradientEndRadius());\n            for (var n = 0; n < colorStops.length; n += 2) {\n                grd.addColorStop(colorStops[n], colorStops[n + 1]);\n            }\n            return grd;\n        }\n    }\n    getShadowRGBA() {\n        return this._getCache(SHADOW_RGBA, this._getShadowRGBA);\n    }\n    _getShadowRGBA() {\n        if (this.hasShadow()) {\n            var rgba = Util.colorToRGBA(this.shadowColor());\n            return ('rgba(' +\n                rgba.r +\n                ',' +\n                rgba.g +\n                ',' +\n                rgba.b +\n                ',' +\n                rgba.a * (this.shadowOpacity() || 1) +\n                ')');\n        }\n    }\n    hasFill() {\n        return this._calculate('hasFill', [\n            'fillEnabled',\n            'fill',\n            'fillPatternImage',\n            'fillLinearGradientColorStops',\n            'fillRadialGradientColorStops',\n        ], () => {\n            return (this.fillEnabled() &&\n                !!(this.fill() ||\n                    this.fillPatternImage() ||\n                    this.fillLinearGradientColorStops() ||\n                    this.fillRadialGradientColorStops()));\n        });\n    }\n    hasStroke() {\n        return this._calculate('hasStroke', [\n            'strokeEnabled',\n            'strokeWidth',\n            'stroke',\n            'strokeLinearGradientColorStops',\n        ], () => {\n            return (this.strokeEnabled() &&\n                this.strokeWidth() &&\n                !!(this.stroke() || this.strokeLinearGradientColorStops()));\n        });\n    }\n    hasHitStroke() {\n        const width = this.hitStrokeWidth();\n        if (width === 'auto') {\n            return this.hasStroke();\n        }\n        return this.strokeEnabled() && !!width;\n    }\n    intersects(point) {\n        var stage = this.getStage(), bufferHitCanvas = stage.bufferHitCanvas, p;\n        bufferHitCanvas.getContext().clear();\n        this.drawHit(bufferHitCanvas, null, true);\n        p = bufferHitCanvas.context.getImageData(Math.round(point.x), Math.round(point.y), 1, 1).data;\n        return p[3] > 0;\n    }\n    destroy() {\n        Node.prototype.destroy.call(this);\n        delete shapes[this.colorKey];\n        delete this.colorKey;\n        return this;\n    }\n    _useBufferCanvas(forceFill) {\n        var _a;\n        if (!this.getStage()) {\n            return false;\n        }\n        const perfectDrawEnabled = (_a = this.attrs.perfectDrawEnabled) !== null && _a !== void 0 ? _a : true;\n        if (!perfectDrawEnabled) {\n            return false;\n        }\n        const hasFill = forceFill || this.hasFill();\n        const hasStroke = this.hasStroke();\n        const isTransparent = this.getAbsoluteOpacity() !== 1;\n        if (hasFill && hasStroke && isTransparent) {\n            return true;\n        }\n        const hasShadow = this.hasShadow();\n        const strokeForShadow = this.shadowForStrokeEnabled();\n        if (hasFill && hasStroke && hasShadow && strokeForShadow) {\n            return true;\n        }\n        return false;\n    }\n    setStrokeHitEnabled(val) {\n        Util.warn('strokeHitEnabled property is deprecated. Please use hitStrokeWidth instead.');\n        if (val) {\n            this.hitStrokeWidth('auto');\n        }\n        else {\n            this.hitStrokeWidth(0);\n        }\n    }\n    getStrokeHitEnabled() {\n        if (this.hitStrokeWidth() === 0) {\n            return false;\n        }\n        else {\n            return true;\n        }\n    }\n    getSelfRect() {\n        var size = this.size();\n        return {\n            x: this._centroid ? -size.width / 2 : 0,\n            y: this._centroid ? -size.height / 2 : 0,\n            width: size.width,\n            height: size.height,\n        };\n    }\n    getClientRect(config = {}) {\n        const skipTransform = config.skipTransform;\n        const relativeTo = config.relativeTo;\n        const fillRect = this.getSelfRect();\n        const applyStroke = !config.skipStroke && this.hasStroke();\n        const strokeWidth = (applyStroke && this.strokeWidth()) || 0;\n        const fillAndStrokeWidth = fillRect.width + strokeWidth;\n        const fillAndStrokeHeight = fillRect.height + strokeWidth;\n        const applyShadow = !config.skipShadow && this.hasShadow();\n        const shadowOffsetX = applyShadow ? this.shadowOffsetX() : 0;\n        const shadowOffsetY = applyShadow ? this.shadowOffsetY() : 0;\n        const preWidth = fillAndStrokeWidth + Math.abs(shadowOffsetX);\n        const preHeight = fillAndStrokeHeight + Math.abs(shadowOffsetY);\n        const blurRadius = (applyShadow && this.shadowBlur()) || 0;\n        const width = preWidth + blurRadius * 2;\n        const height = preHeight + blurRadius * 2;\n        let roundingOffset = 0;\n        if (Math.round(strokeWidth / 2) !== strokeWidth / 2) {\n            roundingOffset = 1;\n        }\n        const rect = {\n            width: width + roundingOffset,\n            height: height + roundingOffset,\n            x: -Math.round(strokeWidth / 2 + blurRadius) +\n                Math.min(shadowOffsetX, 0) +\n                fillRect.x,\n            y: -Math.round(strokeWidth / 2 + blurRadius) +\n                Math.min(shadowOffsetY, 0) +\n                fillRect.y,\n        };\n        if (!skipTransform) {\n            return this._transformedRect(rect, relativeTo);\n        }\n        return rect;\n    }\n    drawScene(can, top) {\n        var layer = this.getLayer(), canvas = can || layer.getCanvas(), context = canvas.getContext(), cachedCanvas = this._getCanvasCache(), drawFunc = this.getSceneFunc(), hasShadow = this.hasShadow(), stage, bufferCanvas, bufferContext;\n        var skipBuffer = canvas.isCache;\n        var cachingSelf = top === this;\n        if (!this.isVisible() && !cachingSelf) {\n            return this;\n        }\n        if (cachedCanvas) {\n            context.save();\n            var m = this.getAbsoluteTransform(top).getMatrix();\n            context.transform(m[0], m[1], m[2], m[3], m[4], m[5]);\n            this._drawCachedSceneCanvas(context);\n            context.restore();\n            return this;\n        }\n        if (!drawFunc) {\n            return this;\n        }\n        context.save();\n        if (this._useBufferCanvas() && !skipBuffer) {\n            stage = this.getStage();\n            bufferCanvas = stage.bufferCanvas;\n            bufferContext = bufferCanvas.getContext();\n            bufferContext.clear();\n            bufferContext.save();\n            bufferContext._applyLineJoin(this);\n            var o = this.getAbsoluteTransform(top).getMatrix();\n            bufferContext.transform(o[0], o[1], o[2], o[3], o[4], o[5]);\n            drawFunc.call(this, bufferContext, this);\n            bufferContext.restore();\n            var ratio = bufferCanvas.pixelRatio;\n            if (hasShadow) {\n                context._applyShadow(this);\n            }\n            context._applyOpacity(this);\n            context._applyGlobalCompositeOperation(this);\n            context.drawImage(bufferCanvas._canvas, 0, 0, bufferCanvas.width / ratio, bufferCanvas.height / ratio);\n        }\n        else {\n            context._applyLineJoin(this);\n            if (!cachingSelf) {\n                var o = this.getAbsoluteTransform(top).getMatrix();\n                context.transform(o[0], o[1], o[2], o[3], o[4], o[5]);\n                context._applyOpacity(this);\n                context._applyGlobalCompositeOperation(this);\n            }\n            if (hasShadow) {\n                context._applyShadow(this);\n            }\n            drawFunc.call(this, context, this);\n        }\n        context.restore();\n        return this;\n    }\n    drawHit(can, top, skipDragCheck = false) {\n        if (!this.shouldDrawHit(top, skipDragCheck)) {\n            return this;\n        }\n        var layer = this.getLayer(), canvas = can || layer.hitCanvas, context = canvas && canvas.getContext(), drawFunc = this.hitFunc() || this.sceneFunc(), cachedCanvas = this._getCanvasCache(), cachedHitCanvas = cachedCanvas && cachedCanvas.hit;\n        if (!this.colorKey) {\n            Util.warn('Looks like your canvas has a destroyed shape in it. Do not reuse shape after you destroyed it. If you want to reuse shape you should call remove() instead of destroy()');\n        }\n        if (cachedHitCanvas) {\n            context.save();\n            var m = this.getAbsoluteTransform(top).getMatrix();\n            context.transform(m[0], m[1], m[2], m[3], m[4], m[5]);\n            this._drawCachedHitCanvas(context);\n            context.restore();\n            return this;\n        }\n        if (!drawFunc) {\n            return this;\n        }\n        context.save();\n        context._applyLineJoin(this);\n        const selfCache = this === top;\n        if (!selfCache) {\n            var o = this.getAbsoluteTransform(top).getMatrix();\n            context.transform(o[0], o[1], o[2], o[3], o[4], o[5]);\n        }\n        drawFunc.call(this, context, this);\n        context.restore();\n        return this;\n    }\n    drawHitFromCache(alphaThreshold = 0) {\n        var cachedCanvas = this._getCanvasCache(), sceneCanvas = this._getCachedSceneCanvas(), hitCanvas = cachedCanvas.hit, hitContext = hitCanvas.getContext(), hitWidth = hitCanvas.getWidth(), hitHeight = hitCanvas.getHeight(), hitImageData, hitData, len, rgbColorKey, i, alpha;\n        hitContext.clear();\n        hitContext.drawImage(sceneCanvas._canvas, 0, 0, hitWidth, hitHeight);\n        try {\n            hitImageData = hitContext.getImageData(0, 0, hitWidth, hitHeight);\n            hitData = hitImageData.data;\n            len = hitData.length;\n            rgbColorKey = Util._hexToRgb(this.colorKey);\n            for (i = 0; i < len; i += 4) {\n                alpha = hitData[i + 3];\n                if (alpha > alphaThreshold) {\n                    hitData[i] = rgbColorKey.r;\n                    hitData[i + 1] = rgbColorKey.g;\n                    hitData[i + 2] = rgbColorKey.b;\n                    hitData[i + 3] = 255;\n                }\n                else {\n                    hitData[i + 3] = 0;\n                }\n            }\n            hitContext.putImageData(hitImageData, 0, 0);\n        }\n        catch (e) {\n            Util.error('Unable to draw hit graph from cached scene canvas. ' + e.message);\n        }\n        return this;\n    }\n    hasPointerCapture(pointerId) {\n        return PointerEvents.hasPointerCapture(pointerId, this);\n    }\n    setPointerCapture(pointerId) {\n        PointerEvents.setPointerCapture(pointerId, this);\n    }\n    releaseCapture(pointerId) {\n        PointerEvents.releaseCapture(pointerId, this);\n    }\n}\nShape.prototype._fillFunc = _fillFunc;\nShape.prototype._strokeFunc = _strokeFunc;\nShape.prototype._fillFuncHit = _fillFuncHit;\nShape.prototype._strokeFuncHit = _strokeFuncHit;\nShape.prototype._centroid = false;\nShape.prototype.nodeType = 'Shape';\n_registerNode(Shape);\nShape.prototype.eventListeners = {};\nShape.prototype.on.call(Shape.prototype, 'shadowColorChange.konva shadowBlurChange.konva shadowOffsetChange.konva shadowOpacityChange.konva shadowEnabledChange.konva', _clearHasShadowCache);\nShape.prototype.on.call(Shape.prototype, 'shadowColorChange.konva shadowOpacityChange.konva shadowEnabledChange.konva', _clearGetShadowRGBACache);\nShape.prototype.on.call(Shape.prototype, 'fillPriorityChange.konva fillPatternImageChange.konva fillPatternRepeatChange.konva fillPatternScaleXChange.konva fillPatternScaleYChange.konva fillPatternOffsetXChange.konva fillPatternOffsetYChange.konva fillPatternXChange.konva fillPatternYChange.konva fillPatternRotationChange.konva', _clearFillPatternCache);\nShape.prototype.on.call(Shape.prototype, 'fillPriorityChange.konva fillLinearGradientColorStopsChange.konva fillLinearGradientStartPointXChange.konva fillLinearGradientStartPointYChange.konva fillLinearGradientEndPointXChange.konva fillLinearGradientEndPointYChange.konva', _clearLinearGradientCache);\nShape.prototype.on.call(Shape.prototype, 'fillPriorityChange.konva fillRadialGradientColorStopsChange.konva fillRadialGradientStartPointXChange.konva fillRadialGradientStartPointYChange.konva fillRadialGradientEndPointXChange.konva fillRadialGradientEndPointYChange.konva fillRadialGradientStartRadiusChange.konva fillRadialGradientEndRadiusChange.konva', _clearRadialGradientCache);\nFactory.addGetterSetter(Shape, 'stroke', undefined, getStringOrGradientValidator());\nFactory.addGetterSetter(Shape, 'strokeWidth', 2, getNumberValidator());\nFactory.addGetterSetter(Shape, 'fillAfterStrokeEnabled', false);\nFactory.addGetterSetter(Shape, 'hitStrokeWidth', 'auto', getNumberOrAutoValidator());\nFactory.addGetterSetter(Shape, 'strokeHitEnabled', true, getBooleanValidator());\nFactory.addGetterSetter(Shape, 'perfectDrawEnabled', true, getBooleanValidator());\nFactory.addGetterSetter(Shape, 'shadowForStrokeEnabled', true, getBooleanValidator());\nFactory.addGetterSetter(Shape, 'lineJoin');\nFactory.addGetterSetter(Shape, 'lineCap');\nFactory.addGetterSetter(Shape, 'sceneFunc');\nFactory.addGetterSetter(Shape, 'hitFunc');\nFactory.addGetterSetter(Shape, 'dash');\nFactory.addGetterSetter(Shape, 'dashOffset', 0, getNumberValidator());\nFactory.addGetterSetter(Shape, 'shadowColor', undefined, getStringValidator());\nFactory.addGetterSetter(Shape, 'shadowBlur', 0, getNumberValidator());\nFactory.addGetterSetter(Shape, 'shadowOpacity', 1, getNumberValidator());\nFactory.addComponentsGetterSetter(Shape, 'shadowOffset', ['x', 'y']);\nFactory.addGetterSetter(Shape, 'shadowOffsetX', 0, getNumberValidator());\nFactory.addGetterSetter(Shape, 'shadowOffsetY', 0, getNumberValidator());\nFactory.addGetterSetter(Shape, 'fillPatternImage');\nFactory.addGetterSetter(Shape, 'fill', undefined, getStringOrGradientValidator());\nFactory.addGetterSetter(Shape, 'fillPatternX', 0, getNumberValidator());\nFactory.addGetterSetter(Shape, 'fillPatternY', 0, getNumberValidator());\nFactory.addGetterSetter(Shape, 'fillLinearGradientColorStops');\nFactory.addGetterSetter(Shape, 'strokeLinearGradientColorStops');\nFactory.addGetterSetter(Shape, 'fillRadialGradientStartRadius', 0);\nFactory.addGetterSetter(Shape, 'fillRadialGradientEndRadius', 0);\nFactory.addGetterSetter(Shape, 'fillRadialGradientColorStops');\nFactory.addGetterSetter(Shape, 'fillPatternRepeat', 'repeat');\nFactory.addGetterSetter(Shape, 'fillEnabled', true);\nFactory.addGetterSetter(Shape, 'strokeEnabled', true);\nFactory.addGetterSetter(Shape, 'shadowEnabled', true);\nFactory.addGetterSetter(Shape, 'dashEnabled', true);\nFactory.addGetterSetter(Shape, 'strokeScaleEnabled', true);\nFactory.addGetterSetter(Shape, 'fillPriority', 'color');\nFactory.addComponentsGetterSetter(Shape, 'fillPatternOffset', ['x', 'y']);\nFactory.addGetterSetter(Shape, 'fillPatternOffsetX', 0, getNumberValidator());\nFactory.addGetterSetter(Shape, 'fillPatternOffsetY', 0, getNumberValidator());\nFactory.addComponentsGetterSetter(Shape, 'fillPatternScale', ['x', 'y']);\nFactory.addGetterSetter(Shape, 'fillPatternScaleX', 1, getNumberValidator());\nFactory.addGetterSetter(Shape, 'fillPatternScaleY', 1, getNumberValidator());\nFactory.addComponentsGetterSetter(Shape, 'fillLinearGradientStartPoint', [\n    'x',\n    'y',\n]);\nFactory.addComponentsGetterSetter(Shape, 'strokeLinearGradientStartPoint', [\n    'x',\n    'y',\n]);\nFactory.addGetterSetter(Shape, 'fillLinearGradientStartPointX', 0);\nFactory.addGetterSetter(Shape, 'strokeLinearGradientStartPointX', 0);\nFactory.addGetterSetter(Shape, 'fillLinearGradientStartPointY', 0);\nFactory.addGetterSetter(Shape, 'strokeLinearGradientStartPointY', 0);\nFactory.addComponentsGetterSetter(Shape, 'fillLinearGradientEndPoint', [\n    'x',\n    'y',\n]);\nFactory.addComponentsGetterSetter(Shape, 'strokeLinearGradientEndPoint', [\n    'x',\n    'y',\n]);\nFactory.addGetterSetter(Shape, 'fillLinearGradientEndPointX', 0);\nFactory.addGetterSetter(Shape, 'strokeLinearGradientEndPointX', 0);\nFactory.addGetterSetter(Shape, 'fillLinearGradientEndPointY', 0);\nFactory.addGetterSetter(Shape, 'strokeLinearGradientEndPointY', 0);\nFactory.addComponentsGetterSetter(Shape, 'fillRadialGradientStartPoint', [\n    'x',\n    'y',\n]);\nFactory.addGetterSetter(Shape, 'fillRadialGradientStartPointX', 0);\nFactory.addGetterSetter(Shape, 'fillRadialGradientStartPointY', 0);\nFactory.addComponentsGetterSetter(Shape, 'fillRadialGradientEndPoint', [\n    'x',\n    'y',\n]);\nFactory.addGetterSetter(Shape, 'fillRadialGradientEndPointX', 0);\nFactory.addGetterSetter(Shape, 'fillRadialGradientEndPointY', 0);\nFactory.addGetterSetter(Shape, 'fillPatternRotation', 0);\nFactory.backCompat(Shape, {\n    dashArray: 'dash',\n    getDashArray: 'getDash',\n    setDashArray: 'getDash',\n    drawFunc: 'sceneFunc',\n    getDrawFunc: 'getSceneFunc',\n    setDrawFunc: 'setSceneFunc',\n    drawHitFunc: 'hitFunc',\n    getDrawHitFunc: 'getHitFunc',\n    setDrawHitFunc: 'setHitFunc',\n});\n//# sourceMappingURL=Shape.js.map"]},"metadata":{},"sourceType":"module"}