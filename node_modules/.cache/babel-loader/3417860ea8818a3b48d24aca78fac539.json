{"ast":null,"code":"import { Util } from './Util.js';\nimport { Container } from './Container.js';\nimport { Node } from './Node.js';\nimport { Factory } from './Factory.js';\nimport { SceneCanvas, HitCanvas } from './Canvas.js';\nimport { getBooleanValidator } from './Validators.js';\nimport { shapes } from './Shape.js';\nimport { _registerNode } from './Global.js';\nvar HASH = '#',\n    BEFORE_DRAW = 'beforeDraw',\n    DRAW = 'draw',\n    INTERSECTION_OFFSETS = [{\n  x: 0,\n  y: 0\n}, {\n  x: -1,\n  y: -1\n}, {\n  x: 1,\n  y: -1\n}, {\n  x: 1,\n  y: 1\n}, {\n  x: -1,\n  y: 1\n}],\n    INTERSECTION_OFFSETS_LEN = INTERSECTION_OFFSETS.length;\nexport class Layer extends Container {\n  constructor(config) {\n    super(config);\n    this.canvas = new SceneCanvas();\n    this.hitCanvas = new HitCanvas({\n      pixelRatio: 1\n    });\n    this._waitingForDraw = false;\n    this.on('visibleChange.konva', this._checkVisibility);\n\n    this._checkVisibility();\n\n    this.on('imageSmoothingEnabledChange.konva', this._setSmoothEnabled);\n\n    this._setSmoothEnabled();\n  }\n\n  createPNGStream() {\n    const c = this.canvas._canvas;\n    return c.createPNGStream();\n  }\n\n  getCanvas() {\n    return this.canvas;\n  }\n\n  getNativeCanvasElement() {\n    return this.canvas._canvas;\n  }\n\n  getHitCanvas() {\n    return this.hitCanvas;\n  }\n\n  getContext() {\n    return this.getCanvas().getContext();\n  }\n\n  clear(bounds) {\n    this.getContext().clear(bounds);\n    this.getHitCanvas().getContext().clear(bounds);\n    return this;\n  }\n\n  setZIndex(index) {\n    super.setZIndex(index);\n    var stage = this.getStage();\n\n    if (stage && stage.content) {\n      stage.content.removeChild(this.getNativeCanvasElement());\n\n      if (index < stage.children.length - 1) {\n        stage.content.insertBefore(this.getNativeCanvasElement(), stage.children[index + 1].getCanvas()._canvas);\n      } else {\n        stage.content.appendChild(this.getNativeCanvasElement());\n      }\n    }\n\n    return this;\n  }\n\n  moveToTop() {\n    Node.prototype.moveToTop.call(this);\n    var stage = this.getStage();\n\n    if (stage && stage.content) {\n      stage.content.removeChild(this.getNativeCanvasElement());\n      stage.content.appendChild(this.getNativeCanvasElement());\n    }\n\n    return true;\n  }\n\n  moveUp() {\n    var moved = Node.prototype.moveUp.call(this);\n\n    if (!moved) {\n      return false;\n    }\n\n    var stage = this.getStage();\n\n    if (!stage || !stage.content) {\n      return false;\n    }\n\n    stage.content.removeChild(this.getNativeCanvasElement());\n\n    if (this.index < stage.children.length - 1) {\n      stage.content.insertBefore(this.getNativeCanvasElement(), stage.children[this.index + 1].getCanvas()._canvas);\n    } else {\n      stage.content.appendChild(this.getNativeCanvasElement());\n    }\n\n    return true;\n  }\n\n  moveDown() {\n    if (Node.prototype.moveDown.call(this)) {\n      var stage = this.getStage();\n\n      if (stage) {\n        var children = stage.children;\n\n        if (stage.content) {\n          stage.content.removeChild(this.getNativeCanvasElement());\n          stage.content.insertBefore(this.getNativeCanvasElement(), children[this.index + 1].getCanvas()._canvas);\n        }\n      }\n\n      return true;\n    }\n\n    return false;\n  }\n\n  moveToBottom() {\n    if (Node.prototype.moveToBottom.call(this)) {\n      var stage = this.getStage();\n\n      if (stage) {\n        var children = stage.children;\n\n        if (stage.content) {\n          stage.content.removeChild(this.getNativeCanvasElement());\n          stage.content.insertBefore(this.getNativeCanvasElement(), children[1].getCanvas()._canvas);\n        }\n      }\n\n      return true;\n    }\n\n    return false;\n  }\n\n  getLayer() {\n    return this;\n  }\n\n  remove() {\n    var _canvas = this.getNativeCanvasElement();\n\n    Node.prototype.remove.call(this);\n\n    if (_canvas && _canvas.parentNode && Util._isInDocument(_canvas)) {\n      _canvas.parentNode.removeChild(_canvas);\n    }\n\n    return this;\n  }\n\n  getStage() {\n    return this.parent;\n  }\n\n  setSize(_ref) {\n    let {\n      width,\n      height\n    } = _ref;\n    this.canvas.setSize(width, height);\n    this.hitCanvas.setSize(width, height);\n\n    this._setSmoothEnabled();\n\n    return this;\n  }\n\n  _validateAdd(child) {\n    var type = child.getType();\n\n    if (type !== 'Group' && type !== 'Shape') {\n      Util.throw('You may only add groups and shapes to a layer.');\n    }\n  }\n\n  _toKonvaCanvas(config) {\n    config = config || {};\n    config.width = config.width || this.getWidth();\n    config.height = config.height || this.getHeight();\n    config.x = config.x !== undefined ? config.x : this.x();\n    config.y = config.y !== undefined ? config.y : this.y();\n    return Node.prototype._toKonvaCanvas.call(this, config);\n  }\n\n  _checkVisibility() {\n    const visible = this.visible();\n\n    if (visible) {\n      this.canvas._canvas.style.display = 'block';\n    } else {\n      this.canvas._canvas.style.display = 'none';\n    }\n  }\n\n  _setSmoothEnabled() {\n    this.getContext()._context.imageSmoothingEnabled = this.imageSmoothingEnabled();\n  }\n\n  getWidth() {\n    if (this.parent) {\n      return this.parent.width();\n    }\n  }\n\n  setWidth() {\n    Util.warn('Can not change width of layer. Use \"stage.width(value)\" function instead.');\n  }\n\n  getHeight() {\n    if (this.parent) {\n      return this.parent.height();\n    }\n  }\n\n  setHeight() {\n    Util.warn('Can not change height of layer. Use \"stage.height(value)\" function instead.');\n  }\n\n  batchDraw() {\n    if (!this._waitingForDraw) {\n      this._waitingForDraw = true;\n      Util.requestAnimFrame(() => {\n        this.draw();\n        this._waitingForDraw = false;\n      });\n    }\n\n    return this;\n  }\n\n  getIntersection(pos) {\n    if (!this.isListening() || !this.isVisible()) {\n      return null;\n    }\n\n    var spiralSearchDistance = 1;\n    var continueSearch = false;\n\n    while (true) {\n      for (let i = 0; i < INTERSECTION_OFFSETS_LEN; i++) {\n        const intersectionOffset = INTERSECTION_OFFSETS[i];\n\n        const obj = this._getIntersection({\n          x: pos.x + intersectionOffset.x * spiralSearchDistance,\n          y: pos.y + intersectionOffset.y * spiralSearchDistance\n        });\n\n        const shape = obj.shape;\n\n        if (shape) {\n          return shape;\n        }\n\n        continueSearch = !!obj.antialiased;\n\n        if (!obj.antialiased) {\n          break;\n        }\n      }\n\n      if (continueSearch) {\n        spiralSearchDistance += 1;\n      } else {\n        return null;\n      }\n    }\n  }\n\n  _getIntersection(pos) {\n    const ratio = this.hitCanvas.pixelRatio;\n    const p = this.hitCanvas.context.getImageData(Math.round(pos.x * ratio), Math.round(pos.y * ratio), 1, 1).data;\n    const p3 = p[3];\n\n    if (p3 === 255) {\n      const colorKey = Util._rgbToHex(p[0], p[1], p[2]);\n\n      const shape = shapes[HASH + colorKey];\n\n      if (shape) {\n        return {\n          shape: shape\n        };\n      }\n\n      return {\n        antialiased: true\n      };\n    } else if (p3 > 0) {\n      return {\n        antialiased: true\n      };\n    }\n\n    return {};\n  }\n\n  drawScene(can, top) {\n    var layer = this.getLayer(),\n        canvas = can || layer && layer.getCanvas();\n\n    this._fire(BEFORE_DRAW, {\n      node: this\n    });\n\n    if (this.clearBeforeDraw()) {\n      canvas.getContext().clear();\n    }\n\n    Container.prototype.drawScene.call(this, canvas, top);\n\n    this._fire(DRAW, {\n      node: this\n    });\n\n    return this;\n  }\n\n  drawHit(can, top) {\n    var layer = this.getLayer(),\n        canvas = can || layer && layer.hitCanvas;\n\n    if (layer && layer.clearBeforeDraw()) {\n      layer.getHitCanvas().getContext().clear();\n    }\n\n    Container.prototype.drawHit.call(this, canvas, top);\n    return this;\n  }\n\n  enableHitGraph() {\n    this.hitGraphEnabled(true);\n    return this;\n  }\n\n  disableHitGraph() {\n    this.hitGraphEnabled(false);\n    return this;\n  }\n\n  setHitGraphEnabled(val) {\n    Util.warn('hitGraphEnabled method is deprecated. Please use layer.listening() instead.');\n    this.listening(val);\n  }\n\n  getHitGraphEnabled(val) {\n    Util.warn('hitGraphEnabled method is deprecated. Please use layer.listening() instead.');\n    return this.listening();\n  }\n\n  toggleHitCanvas() {\n    if (!this.parent || !this.parent['content']) {\n      return;\n    }\n\n    var parent = this.parent;\n    var added = !!this.hitCanvas._canvas.parentNode;\n\n    if (added) {\n      parent.content.removeChild(this.hitCanvas._canvas);\n    } else {\n      parent.content.appendChild(this.hitCanvas._canvas);\n    }\n  }\n\n}\nLayer.prototype.nodeType = 'Layer';\n\n_registerNode(Layer);\n\nFactory.addGetterSetter(Layer, 'imageSmoothingEnabled', true);\nFactory.addGetterSetter(Layer, 'clearBeforeDraw', true);\nFactory.addGetterSetter(Layer, 'hitGraphEnabled', true, getBooleanValidator());","map":{"version":3,"sources":["../src/Layer.ts"],"names":[],"mappings":"AAAA,SAAS,IAAT,QAAqB,WAArB;AACA,SAAS,SAAT,QAA2C,gBAA3C;AACA,SAAS,IAAT,QAAqB,WAArB;AACA,SAAS,OAAT,QAAwB,cAAxB;AACA,SAAS,WAAT,EAAsB,SAAtB,QAAuC,aAAvC;AAEA,SAAS,mBAAT,QAAoC,iBAApC;AAIA,SAAgB,MAAhB,QAA8B,YAA9B;AACA,SAAS,aAAT,QAA8B,aAA9B;AASA,IAAI,IAAI,GAAG,GAAX;AAAA,IACE,WAAW,GAAG,YADhB;AAAA,IAEE,IAAI,GAAG,MAFT;AAAA,IAUE,oBAAoB,GAAG,CACrB;AAAE,EAAA,CAAC,EAAE,CAAL;AAAQ,EAAA,CAAC,EAAE;AAAX,CADqB,EAErB;AAAE,EAAA,CAAC,EAAE,CAAC,CAAN;AAAS,EAAA,CAAC,EAAE,CAAC;AAAb,CAFqB,EAGrB;AAAE,EAAA,CAAC,EAAE,CAAL;AAAQ,EAAA,CAAC,EAAE,CAAC;AAAZ,CAHqB,EAIrB;AAAE,EAAA,CAAC,EAAE,CAAL;AAAQ,EAAA,CAAC,EAAE;AAAX,CAJqB,EAKrB;AAAE,EAAA,CAAC,EAAE,CAAC,CAAN;AAAS,EAAA,CAAC,EAAE;AAAZ,CALqB,CAVzB;AAAA,IAiBE,wBAAwB,GAAG,oBAAoB,CAAC,MAjBlD;AAoCA,OAAM,MAAO,KAAP,SAAqB,SAArB,CAA6C;AAQjD,EAAA,WAAA,CAAY,MAAZ,EAAgC;AAC9B,UAAM,MAAN;AARF,SAAA,MAAA,GAAS,IAAI,WAAJ,EAAT;AACA,SAAA,SAAA,GAAY,IAAI,SAAJ,CAAc;AACxB,MAAA,UAAU,EAAE;AADY,KAAd,CAAZ;AAIA,SAAA,eAAA,GAAkB,KAAlB;AAIE,SAAK,EAAL,CAAQ,qBAAR,EAA+B,KAAK,gBAApC;;AACA,SAAK,gBAAL;;AAEA,SAAK,EAAL,CAAQ,mCAAR,EAA6C,KAAK,iBAAlD;;AACA,SAAK,iBAAL;AACD;;AAED,EAAA,eAAe,GAAA;AACb,UAAM,CAAC,GAAG,KAAK,MAAL,CAAY,OAAtB;AACA,WAAO,CAAC,CAAC,eAAF,EAAP;AACD;;AAMD,EAAA,SAAS,GAAA;AACP,WAAO,KAAK,MAAZ;AACD;;AAMD,EAAA,sBAAsB,GAAA;AACpB,WAAO,KAAK,MAAL,CAAY,OAAnB;AACD;;AAMD,EAAA,YAAY,GAAA;AACV,WAAO,KAAK,SAAZ;AACD;;AAMD,EAAA,UAAU,GAAA;AACR,WAAO,KAAK,SAAL,GAAiB,UAAjB,EAAP;AACD;;AAED,EAAA,KAAK,CAAC,MAAD,EAAQ;AACX,SAAK,UAAL,GAAkB,KAAlB,CAAwB,MAAxB;AACA,SAAK,YAAL,GAAoB,UAApB,GAAiC,KAAjC,CAAuC,MAAvC;AACA,WAAO,IAAP;AACD;;AAED,EAAA,SAAS,CAAC,KAAD,EAAM;AACb,UAAM,SAAN,CAAgB,KAAhB;AACA,QAAI,KAAK,GAAG,KAAK,QAAL,EAAZ;;AACA,QAAI,KAAK,IAAI,KAAK,CAAC,OAAnB,EAA4B;AAC1B,MAAA,KAAK,CAAC,OAAN,CAAc,WAAd,CAA0B,KAAK,sBAAL,EAA1B;;AAEA,UAAI,KAAK,GAAG,KAAK,CAAC,QAAN,CAAe,MAAf,GAAwB,CAApC,EAAuC;AACrC,QAAA,KAAK,CAAC,OAAN,CAAc,YAAd,CACE,KAAK,sBAAL,EADF,EAEE,KAAK,CAAC,QAAN,CAAe,KAAK,GAAG,CAAvB,EAA0B,SAA1B,GAAsC,OAFxC;AAID,OALD,MAKO;AACL,QAAA,KAAK,CAAC,OAAN,CAAc,WAAd,CAA0B,KAAK,sBAAL,EAA1B;AACD;AACF;;AACD,WAAO,IAAP;AACD;;AACD,EAAA,SAAS,GAAA;AACP,IAAA,IAAI,CAAC,SAAL,CAAe,SAAf,CAAyB,IAAzB,CAA8B,IAA9B;AACA,QAAI,KAAK,GAAG,KAAK,QAAL,EAAZ;;AACA,QAAI,KAAK,IAAI,KAAK,CAAC,OAAnB,EAA4B;AAC1B,MAAA,KAAK,CAAC,OAAN,CAAc,WAAd,CAA0B,KAAK,sBAAL,EAA1B;AACA,MAAA,KAAK,CAAC,OAAN,CAAc,WAAd,CAA0B,KAAK,sBAAL,EAA1B;AACD;;AACD,WAAO,IAAP;AACD;;AACD,EAAA,MAAM,GAAA;AACJ,QAAI,KAAK,GAAG,IAAI,CAAC,SAAL,CAAe,MAAf,CAAsB,IAAtB,CAA2B,IAA3B,CAAZ;;AACA,QAAI,CAAC,KAAL,EAAY;AACV,aAAO,KAAP;AACD;;AACD,QAAI,KAAK,GAAG,KAAK,QAAL,EAAZ;;AACA,QAAI,CAAC,KAAD,IAAU,CAAC,KAAK,CAAC,OAArB,EAA8B;AAC5B,aAAO,KAAP;AACD;;AACD,IAAA,KAAK,CAAC,OAAN,CAAc,WAAd,CAA0B,KAAK,sBAAL,EAA1B;;AAEA,QAAI,KAAK,KAAL,GAAa,KAAK,CAAC,QAAN,CAAe,MAAf,GAAwB,CAAzC,EAA4C;AAC1C,MAAA,KAAK,CAAC,OAAN,CAAc,YAAd,CACE,KAAK,sBAAL,EADF,EAEE,KAAK,CAAC,QAAN,CAAe,KAAK,KAAL,GAAa,CAA5B,EAA+B,SAA/B,GAA2C,OAF7C;AAID,KALD,MAKO;AACL,MAAA,KAAK,CAAC,OAAN,CAAc,WAAd,CAA0B,KAAK,sBAAL,EAA1B;AACD;;AACD,WAAO,IAAP;AACD;;AAED,EAAA,QAAQ,GAAA;AACN,QAAI,IAAI,CAAC,SAAL,CAAe,QAAf,CAAwB,IAAxB,CAA6B,IAA7B,CAAJ,EAAwC;AACtC,UAAI,KAAK,GAAG,KAAK,QAAL,EAAZ;;AACA,UAAI,KAAJ,EAAW;AACT,YAAI,QAAQ,GAAG,KAAK,CAAC,QAArB;;AACA,YAAI,KAAK,CAAC,OAAV,EAAmB;AACjB,UAAA,KAAK,CAAC,OAAN,CAAc,WAAd,CAA0B,KAAK,sBAAL,EAA1B;AACA,UAAA,KAAK,CAAC,OAAN,CAAc,YAAd,CACE,KAAK,sBAAL,EADF,EAEE,QAAQ,CAAC,KAAK,KAAL,GAAa,CAAd,CAAR,CAAyB,SAAzB,GAAqC,OAFvC;AAID;AACF;;AACD,aAAO,IAAP;AACD;;AACD,WAAO,KAAP;AACD;;AAED,EAAA,YAAY,GAAA;AACV,QAAI,IAAI,CAAC,SAAL,CAAe,YAAf,CAA4B,IAA5B,CAAiC,IAAjC,CAAJ,EAA4C;AAC1C,UAAI,KAAK,GAAG,KAAK,QAAL,EAAZ;;AACA,UAAI,KAAJ,EAAW;AACT,YAAI,QAAQ,GAAG,KAAK,CAAC,QAArB;;AACA,YAAI,KAAK,CAAC,OAAV,EAAmB;AACjB,UAAA,KAAK,CAAC,OAAN,CAAc,WAAd,CAA0B,KAAK,sBAAL,EAA1B;AACA,UAAA,KAAK,CAAC,OAAN,CAAc,YAAd,CACE,KAAK,sBAAL,EADF,EAEE,QAAQ,CAAC,CAAD,CAAR,CAAY,SAAZ,GAAwB,OAF1B;AAID;AACF;;AACD,aAAO,IAAP;AACD;;AACD,WAAO,KAAP;AACD;;AACD,EAAA,QAAQ,GAAA;AACN,WAAO,IAAP;AACD;;AACD,EAAA,MAAM,GAAA;AACJ,QAAI,OAAO,GAAG,KAAK,sBAAL,EAAd;;AAEA,IAAA,IAAI,CAAC,SAAL,CAAe,MAAf,CAAsB,IAAtB,CAA2B,IAA3B;;AAEA,QAAI,OAAO,IAAI,OAAO,CAAC,UAAnB,IAAiC,IAAI,CAAC,aAAL,CAAmB,OAAnB,CAArC,EAAkE;AAChE,MAAA,OAAO,CAAC,UAAR,CAAmB,WAAnB,CAA+B,OAA/B;AACD;;AACD,WAAO,IAAP;AACD;;AACD,EAAA,QAAQ,GAAA;AACN,WAAO,KAAK,MAAZ;AACD;;AACD,EAAA,OAAO,OAAkB;AAAA,QAAjB;AAAE,MAAA,KAAF;AAAS,MAAA;AAAT,KAAiB;AACvB,SAAK,MAAL,CAAY,OAAZ,CAAoB,KAApB,EAA2B,MAA3B;AACA,SAAK,SAAL,CAAe,OAAf,CAAuB,KAAvB,EAA8B,MAA9B;;AACA,SAAK,iBAAL;;AACA,WAAO,IAAP;AACD;;AACD,EAAA,YAAY,CAAC,KAAD,EAAM;AAChB,QAAI,IAAI,GAAG,KAAK,CAAC,OAAN,EAAX;;AACA,QAAI,IAAI,KAAK,OAAT,IAAoB,IAAI,KAAK,OAAjC,EAA0C;AACxC,MAAA,IAAI,CAAC,KAAL,CAAW,gDAAX;AACD;AACF;;AACD,EAAA,cAAc,CAAC,MAAD,EAAO;AACnB,IAAA,MAAM,GAAG,MAAM,IAAI,EAAnB;AACA,IAAA,MAAM,CAAC,KAAP,GAAe,MAAM,CAAC,KAAP,IAAgB,KAAK,QAAL,EAA/B;AACA,IAAA,MAAM,CAAC,MAAP,GAAgB,MAAM,CAAC,MAAP,IAAiB,KAAK,SAAL,EAAjC;AACA,IAAA,MAAM,CAAC,CAAP,GAAW,MAAM,CAAC,CAAP,KAAa,SAAb,GAAyB,MAAM,CAAC,CAAhC,GAAoC,KAAK,CAAL,EAA/C;AACA,IAAA,MAAM,CAAC,CAAP,GAAW,MAAM,CAAC,CAAP,KAAa,SAAb,GAAyB,MAAM,CAAC,CAAhC,GAAoC,KAAK,CAAL,EAA/C;AAEA,WAAO,IAAI,CAAC,SAAL,CAAe,cAAf,CAA8B,IAA9B,CAAmC,IAAnC,EAAyC,MAAzC,CAAP;AACD;;AAED,EAAA,gBAAgB,GAAA;AACd,UAAM,OAAO,GAAG,KAAK,OAAL,EAAhB;;AACA,QAAI,OAAJ,EAAa;AACX,WAAK,MAAL,CAAY,OAAZ,CAAoB,KAApB,CAA0B,OAA1B,GAAoC,OAApC;AACD,KAFD,MAEO;AACL,WAAK,MAAL,CAAY,OAAZ,CAAoB,KAApB,CAA0B,OAA1B,GAAoC,MAApC;AACD;AACF;;AAED,EAAA,iBAAiB,GAAA;AACf,SAAK,UAAL,GAAkB,QAAlB,CAA2B,qBAA3B,GACE,KAAK,qBAAL,EADF;AAED;;AAUD,EAAA,QAAQ,GAAA;AACN,QAAI,KAAK,MAAT,EAAiB;AACf,aAAO,KAAK,MAAL,CAAY,KAAZ,EAAP;AACD;AACF;;AACD,EAAA,QAAQ,GAAA;AACN,IAAA,IAAI,CAAC,IAAL,CACE,2EADF;AAGD;;AAUD,EAAA,SAAS,GAAA;AACP,QAAI,KAAK,MAAT,EAAiB;AACf,aAAO,KAAK,MAAL,CAAY,MAAZ,EAAP;AACD;AACF;;AACD,EAAA,SAAS,GAAA;AACP,IAAA,IAAI,CAAC,IAAL,CACE,6EADF;AAGD;;AASD,EAAA,SAAS,GAAA;AACP,QAAI,CAAC,KAAK,eAAV,EAA2B;AACzB,WAAK,eAAL,GAAuB,IAAvB;AACA,MAAA,IAAI,CAAC,gBAAL,CAAsB,MAAK;AACzB,aAAK,IAAL;AACA,aAAK,eAAL,GAAuB,KAAvB;AACD,OAHD;AAID;;AACD,WAAO,IAAP;AACD;;AAeD,EAAA,eAAe,CAAC,GAAD,EAAc;AAC3B,QAAI,CAAC,KAAK,WAAL,EAAD,IAAuB,CAAC,KAAK,SAAL,EAA5B,EAA8C;AAC5C,aAAO,IAAP;AACD;;AAGD,QAAI,oBAAoB,GAAG,CAA3B;AACA,QAAI,cAAc,GAAG,KAArB;;AACA,WAAO,IAAP,EAAa;AACX,WAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,wBAApB,EAA8C,CAAC,EAA/C,EAAmD;AACjD,cAAM,kBAAkB,GAAG,oBAAoB,CAAC,CAAD,CAA/C;;AACA,cAAM,GAAG,GAAG,KAAK,gBAAL,CAAsB;AAChC,UAAA,CAAC,EAAE,GAAG,CAAC,CAAJ,GAAQ,kBAAkB,CAAC,CAAnB,GAAuB,oBADF;AAEhC,UAAA,CAAC,EAAE,GAAG,CAAC,CAAJ,GAAQ,kBAAkB,CAAC,CAAnB,GAAuB;AAFF,SAAtB,CAAZ;;AAIA,cAAM,KAAK,GAAG,GAAG,CAAC,KAAlB;;AACA,YAAI,KAAJ,EAAW;AACT,iBAAO,KAAP;AACD;;AAGD,QAAA,cAAc,GAAG,CAAC,CAAC,GAAG,CAAC,WAAvB;;AAEA,YAAI,CAAC,GAAG,CAAC,WAAT,EAAsB;AACpB;AACD;AACF;;AAED,UAAI,cAAJ,EAAoB;AAClB,QAAA,oBAAoB,IAAI,CAAxB;AACD,OAFD,MAEO;AACL,eAAO,IAAP;AACD;AACF;AACF;;AACD,EAAA,gBAAgB,CAAC,GAAD,EAAc;AAC5B,UAAM,KAAK,GAAG,KAAK,SAAL,CAAe,UAA7B;AACA,UAAM,CAAC,GAAG,KAAK,SAAL,CAAe,OAAf,CAAuB,YAAvB,CACR,IAAI,CAAC,KAAL,CAAW,GAAG,CAAC,CAAJ,GAAQ,KAAnB,CADQ,EAER,IAAI,CAAC,KAAL,CAAW,GAAG,CAAC,CAAJ,GAAQ,KAAnB,CAFQ,EAGR,CAHQ,EAIR,CAJQ,EAKR,IALF;AAMA,UAAM,EAAE,GAAG,CAAC,CAAC,CAAD,CAAZ;;AAGA,QAAI,EAAE,KAAK,GAAX,EAAgB;AACd,YAAM,QAAQ,GAAG,IAAI,CAAC,SAAL,CAAe,CAAC,CAAC,CAAD,CAAhB,EAAqB,CAAC,CAAC,CAAD,CAAtB,EAA2B,CAAC,CAAC,CAAD,CAA5B,CAAjB;;AACA,YAAM,KAAK,GAAG,MAAM,CAAC,IAAI,GAAG,QAAR,CAApB;;AACA,UAAI,KAAJ,EAAW;AACT,eAAO;AACL,UAAA,KAAK,EAAE;AADF,SAAP;AAGD;;AACD,aAAO;AACL,QAAA,WAAW,EAAE;AADR,OAAP;AAGD,KAXD,MAWO,IAAI,EAAE,GAAG,CAAT,EAAY;AAEjB,aAAO;AACL,QAAA,WAAW,EAAE;AADR,OAAP;AAGD;;AAED,WAAO,EAAP;AACD;;AACD,EAAA,SAAS,CAAC,GAAD,EAAoB,GAApB,EAA8B;AACrC,QAAI,KAAK,GAAG,KAAK,QAAL,EAAZ;AAAA,QACE,MAAM,GAAG,GAAG,IAAK,KAAK,IAAI,KAAK,CAAC,SAAN,EAD5B;;AAGA,SAAK,KAAL,CAAW,WAAX,EAAwB;AACtB,MAAA,IAAI,EAAE;AADgB,KAAxB;;AAIA,QAAI,KAAK,eAAL,EAAJ,EAA4B;AAC1B,MAAA,MAAM,CAAC,UAAP,GAAoB,KAApB;AACD;;AAED,IAAA,SAAS,CAAC,SAAV,CAAoB,SAApB,CAA8B,IAA9B,CAAmC,IAAnC,EAAyC,MAAzC,EAAiD,GAAjD;;AAEA,SAAK,KAAL,CAAW,IAAX,EAAiB;AACf,MAAA,IAAI,EAAE;AADS,KAAjB;;AAIA,WAAO,IAAP;AACD;;AACD,EAAA,OAAO,CAAC,GAAD,EAAkB,GAAlB,EAA4B;AACjC,QAAI,KAAK,GAAG,KAAK,QAAL,EAAZ;AAAA,QACE,MAAM,GAAG,GAAG,IAAK,KAAK,IAAI,KAAK,CAAC,SADlC;;AAGA,QAAI,KAAK,IAAI,KAAK,CAAC,eAAN,EAAb,EAAsC;AACpC,MAAA,KAAK,CAAC,YAAN,GAAqB,UAArB,GAAkC,KAAlC;AACD;;AAED,IAAA,SAAS,CAAC,SAAV,CAAoB,OAApB,CAA4B,IAA5B,CAAiC,IAAjC,EAAuC,MAAvC,EAA+C,GAA/C;AACA,WAAO,IAAP;AACD;;AAOD,EAAA,cAAc,GAAA;AACZ,SAAK,eAAL,CAAqB,IAArB;AACA,WAAO,IAAP;AACD;;AAOD,EAAA,eAAe,GAAA;AACb,SAAK,eAAL,CAAqB,KAArB;AACA,WAAO,IAAP;AACD;;AAED,EAAA,kBAAkB,CAAC,GAAD,EAAI;AACpB,IAAA,IAAI,CAAC,IAAL,CACE,6EADF;AAGA,SAAK,SAAL,CAAe,GAAf;AACD;;AAED,EAAA,kBAAkB,CAAC,GAAD,EAAI;AACpB,IAAA,IAAI,CAAC,IAAL,CACE,6EADF;AAGA,WAAO,KAAK,SAAL,EAAP;AACD;;AAOD,EAAA,eAAe,GAAA;AACb,QAAI,CAAC,KAAK,MAAN,IAAgB,CAAC,KAAK,MAAL,CAAY,SAAZ,CAArB,EAA6C;AAC3C;AACD;;AACD,QAAI,MAAM,GAAG,KAAK,MAAlB;AACA,QAAI,KAAK,GAAG,CAAC,CAAC,KAAK,SAAL,CAAe,OAAf,CAAuB,UAArC;;AACA,QAAI,KAAJ,EAAW;AACT,MAAA,MAAM,CAAC,OAAP,CAAe,WAAf,CAA2B,KAAK,SAAL,CAAe,OAA1C;AACD,KAFD,MAEO;AACL,MAAA,MAAM,CAAC,OAAP,CAAe,WAAf,CAA2B,KAAK,SAAL,CAAe,OAA1C;AACD;AACF;;AA5ZgD;AAoanD,KAAK,CAAC,SAAN,CAAgB,QAAhB,GAA2B,OAA3B;;AACA,aAAa,CAAC,KAAD,CAAb;;AAiBA,OAAO,CAAC,eAAR,CAAwB,KAAxB,EAA+B,uBAA/B,EAAwD,IAAxD;AAmBA,OAAO,CAAC,eAAR,CAAwB,KAAxB,EAA+B,iBAA/B,EAAkD,IAAlD;AAEA,OAAO,CAAC,eAAR,CAAwB,KAAxB,EAA+B,iBAA/B,EAAkD,IAAlD,EAAwD,mBAAmB,EAA3E","sourceRoot":"","sourcesContent":["import { Util } from './Util.js';\nimport { Container } from './Container.js';\nimport { Node } from './Node.js';\nimport { Factory } from './Factory.js';\nimport { SceneCanvas, HitCanvas } from './Canvas.js';\nimport { getBooleanValidator } from './Validators.js';\nimport { shapes } from './Shape.js';\nimport { _registerNode } from './Global.js';\nvar HASH = '#', BEFORE_DRAW = 'beforeDraw', DRAW = 'draw', INTERSECTION_OFFSETS = [\n    { x: 0, y: 0 },\n    { x: -1, y: -1 },\n    { x: 1, y: -1 },\n    { x: 1, y: 1 },\n    { x: -1, y: 1 },\n], INTERSECTION_OFFSETS_LEN = INTERSECTION_OFFSETS.length;\nexport class Layer extends Container {\n    constructor(config) {\n        super(config);\n        this.canvas = new SceneCanvas();\n        this.hitCanvas = new HitCanvas({\n            pixelRatio: 1,\n        });\n        this._waitingForDraw = false;\n        this.on('visibleChange.konva', this._checkVisibility);\n        this._checkVisibility();\n        this.on('imageSmoothingEnabledChange.konva', this._setSmoothEnabled);\n        this._setSmoothEnabled();\n    }\n    createPNGStream() {\n        const c = this.canvas._canvas;\n        return c.createPNGStream();\n    }\n    getCanvas() {\n        return this.canvas;\n    }\n    getNativeCanvasElement() {\n        return this.canvas._canvas;\n    }\n    getHitCanvas() {\n        return this.hitCanvas;\n    }\n    getContext() {\n        return this.getCanvas().getContext();\n    }\n    clear(bounds) {\n        this.getContext().clear(bounds);\n        this.getHitCanvas().getContext().clear(bounds);\n        return this;\n    }\n    setZIndex(index) {\n        super.setZIndex(index);\n        var stage = this.getStage();\n        if (stage && stage.content) {\n            stage.content.removeChild(this.getNativeCanvasElement());\n            if (index < stage.children.length - 1) {\n                stage.content.insertBefore(this.getNativeCanvasElement(), stage.children[index + 1].getCanvas()._canvas);\n            }\n            else {\n                stage.content.appendChild(this.getNativeCanvasElement());\n            }\n        }\n        return this;\n    }\n    moveToTop() {\n        Node.prototype.moveToTop.call(this);\n        var stage = this.getStage();\n        if (stage && stage.content) {\n            stage.content.removeChild(this.getNativeCanvasElement());\n            stage.content.appendChild(this.getNativeCanvasElement());\n        }\n        return true;\n    }\n    moveUp() {\n        var moved = Node.prototype.moveUp.call(this);\n        if (!moved) {\n            return false;\n        }\n        var stage = this.getStage();\n        if (!stage || !stage.content) {\n            return false;\n        }\n        stage.content.removeChild(this.getNativeCanvasElement());\n        if (this.index < stage.children.length - 1) {\n            stage.content.insertBefore(this.getNativeCanvasElement(), stage.children[this.index + 1].getCanvas()._canvas);\n        }\n        else {\n            stage.content.appendChild(this.getNativeCanvasElement());\n        }\n        return true;\n    }\n    moveDown() {\n        if (Node.prototype.moveDown.call(this)) {\n            var stage = this.getStage();\n            if (stage) {\n                var children = stage.children;\n                if (stage.content) {\n                    stage.content.removeChild(this.getNativeCanvasElement());\n                    stage.content.insertBefore(this.getNativeCanvasElement(), children[this.index + 1].getCanvas()._canvas);\n                }\n            }\n            return true;\n        }\n        return false;\n    }\n    moveToBottom() {\n        if (Node.prototype.moveToBottom.call(this)) {\n            var stage = this.getStage();\n            if (stage) {\n                var children = stage.children;\n                if (stage.content) {\n                    stage.content.removeChild(this.getNativeCanvasElement());\n                    stage.content.insertBefore(this.getNativeCanvasElement(), children[1].getCanvas()._canvas);\n                }\n            }\n            return true;\n        }\n        return false;\n    }\n    getLayer() {\n        return this;\n    }\n    remove() {\n        var _canvas = this.getNativeCanvasElement();\n        Node.prototype.remove.call(this);\n        if (_canvas && _canvas.parentNode && Util._isInDocument(_canvas)) {\n            _canvas.parentNode.removeChild(_canvas);\n        }\n        return this;\n    }\n    getStage() {\n        return this.parent;\n    }\n    setSize({ width, height }) {\n        this.canvas.setSize(width, height);\n        this.hitCanvas.setSize(width, height);\n        this._setSmoothEnabled();\n        return this;\n    }\n    _validateAdd(child) {\n        var type = child.getType();\n        if (type !== 'Group' && type !== 'Shape') {\n            Util.throw('You may only add groups and shapes to a layer.');\n        }\n    }\n    _toKonvaCanvas(config) {\n        config = config || {};\n        config.width = config.width || this.getWidth();\n        config.height = config.height || this.getHeight();\n        config.x = config.x !== undefined ? config.x : this.x();\n        config.y = config.y !== undefined ? config.y : this.y();\n        return Node.prototype._toKonvaCanvas.call(this, config);\n    }\n    _checkVisibility() {\n        const visible = this.visible();\n        if (visible) {\n            this.canvas._canvas.style.display = 'block';\n        }\n        else {\n            this.canvas._canvas.style.display = 'none';\n        }\n    }\n    _setSmoothEnabled() {\n        this.getContext()._context.imageSmoothingEnabled =\n            this.imageSmoothingEnabled();\n    }\n    getWidth() {\n        if (this.parent) {\n            return this.parent.width();\n        }\n    }\n    setWidth() {\n        Util.warn('Can not change width of layer. Use \"stage.width(value)\" function instead.');\n    }\n    getHeight() {\n        if (this.parent) {\n            return this.parent.height();\n        }\n    }\n    setHeight() {\n        Util.warn('Can not change height of layer. Use \"stage.height(value)\" function instead.');\n    }\n    batchDraw() {\n        if (!this._waitingForDraw) {\n            this._waitingForDraw = true;\n            Util.requestAnimFrame(() => {\n                this.draw();\n                this._waitingForDraw = false;\n            });\n        }\n        return this;\n    }\n    getIntersection(pos) {\n        if (!this.isListening() || !this.isVisible()) {\n            return null;\n        }\n        var spiralSearchDistance = 1;\n        var continueSearch = false;\n        while (true) {\n            for (let i = 0; i < INTERSECTION_OFFSETS_LEN; i++) {\n                const intersectionOffset = INTERSECTION_OFFSETS[i];\n                const obj = this._getIntersection({\n                    x: pos.x + intersectionOffset.x * spiralSearchDistance,\n                    y: pos.y + intersectionOffset.y * spiralSearchDistance,\n                });\n                const shape = obj.shape;\n                if (shape) {\n                    return shape;\n                }\n                continueSearch = !!obj.antialiased;\n                if (!obj.antialiased) {\n                    break;\n                }\n            }\n            if (continueSearch) {\n                spiralSearchDistance += 1;\n            }\n            else {\n                return null;\n            }\n        }\n    }\n    _getIntersection(pos) {\n        const ratio = this.hitCanvas.pixelRatio;\n        const p = this.hitCanvas.context.getImageData(Math.round(pos.x * ratio), Math.round(pos.y * ratio), 1, 1).data;\n        const p3 = p[3];\n        if (p3 === 255) {\n            const colorKey = Util._rgbToHex(p[0], p[1], p[2]);\n            const shape = shapes[HASH + colorKey];\n            if (shape) {\n                return {\n                    shape: shape,\n                };\n            }\n            return {\n                antialiased: true,\n            };\n        }\n        else if (p3 > 0) {\n            return {\n                antialiased: true,\n            };\n        }\n        return {};\n    }\n    drawScene(can, top) {\n        var layer = this.getLayer(), canvas = can || (layer && layer.getCanvas());\n        this._fire(BEFORE_DRAW, {\n            node: this,\n        });\n        if (this.clearBeforeDraw()) {\n            canvas.getContext().clear();\n        }\n        Container.prototype.drawScene.call(this, canvas, top);\n        this._fire(DRAW, {\n            node: this,\n        });\n        return this;\n    }\n    drawHit(can, top) {\n        var layer = this.getLayer(), canvas = can || (layer && layer.hitCanvas);\n        if (layer && layer.clearBeforeDraw()) {\n            layer.getHitCanvas().getContext().clear();\n        }\n        Container.prototype.drawHit.call(this, canvas, top);\n        return this;\n    }\n    enableHitGraph() {\n        this.hitGraphEnabled(true);\n        return this;\n    }\n    disableHitGraph() {\n        this.hitGraphEnabled(false);\n        return this;\n    }\n    setHitGraphEnabled(val) {\n        Util.warn('hitGraphEnabled method is deprecated. Please use layer.listening() instead.');\n        this.listening(val);\n    }\n    getHitGraphEnabled(val) {\n        Util.warn('hitGraphEnabled method is deprecated. Please use layer.listening() instead.');\n        return this.listening();\n    }\n    toggleHitCanvas() {\n        if (!this.parent || !this.parent['content']) {\n            return;\n        }\n        var parent = this.parent;\n        var added = !!this.hitCanvas._canvas.parentNode;\n        if (added) {\n            parent.content.removeChild(this.hitCanvas._canvas);\n        }\n        else {\n            parent.content.appendChild(this.hitCanvas._canvas);\n        }\n    }\n}\nLayer.prototype.nodeType = 'Layer';\n_registerNode(Layer);\nFactory.addGetterSetter(Layer, 'imageSmoothingEnabled', true);\nFactory.addGetterSetter(Layer, 'clearBeforeDraw', true);\nFactory.addGetterSetter(Layer, 'hitGraphEnabled', true, getBooleanValidator());\n//# sourceMappingURL=Layer.js.map"]},"metadata":{},"sourceType":"module"}